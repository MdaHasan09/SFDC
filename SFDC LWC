Salesforce LWC
Table of Contents
IMPORTANT TOPICS	6
1)	BASICS OF HTML	6
2)	BASICS OF CSS	10
3)	JAVASCRIPT FOR LWC	16
Variables	17
Data Type	24
Spread operator	27
Destructuring	29
String Interpolation	30
String Methods	31
Object/JSON operations	33
Array Methods	34
Promise	37
Modules Import and Export	39
Query selector	42
Event	43
Arrow Function	47
Set Timeout &Set Interval	51
4)	INTRODUCTION TO LWC	52
5)	FUNDAMENTALS OF LWC	58
Local Properties and Data binding	60
@api Decorator	63
Track Property	63
Getters n LWC	66
Conditional Rendering	68
Template Looping in HTML	71
Quiz App	76
Component Composition	79
Shadow DOM	80
Accessing elements in the Components	83
6)	STYLING IN LWC	84
Inline and External CSS	85
Lightning Design system	86
SLDS Design token	88
Shared CSS	88
Dynamic Styling	90
Styling Across shadow DOM	90
7)	COMPONENT LIFE CYCLE HOOKS	91
Life Cycle Hooks in mounting phase	92
Life cycle hooks in Unmounting phase	96
Error Phase	98
Render Method	101
8)	COMPONENT COMMUNICATION	105
Parent to child communication	105
Parent to child communication using Primitive data type	106
Parent to child communication using Non-Primitive data type	109
Parent to child communication On action at Parent component	111
Calling child method from parent component	113
Child to Parent communication	116
Child to parent communication using simple event	117
Child to parent using communication using event with data	119
Child to parent communication using event bubbling	121
Sibling component communication using Pubsub	123
Setter method in Parent child Component	126
Passing markup using slots in Parent child comp	128
CSS behavior in Parent child component	130
Building Reusable component	132
Aura Coexistence	134
9)	LIGHTNING MESSAGING SERVICE	136
LWC to LWC communication using LMS	138
LWC to Aura communication using LMS	141
LWC, Aura and VF communication using LMS	146
10)	RESOURCES , COMPONENT CONTEXT AND NOTIFICATION	148
Images from Static resources	149
Third party Java Script libraries in LWC	151
Third party CSS libraries in LWC	152
Content asset files	154
Internationalization	155
Access lables	157
Check Permissions	158
Access client form factor	160
Get current user information	161
Fetch Record ID and Object name	162
Toast Notification	163
11)	MEMORY GAME PROJECT	166
12)	NAVIGATION SERVICE	173
Navigate to Home	175
Navigate to Chatter	177
Navigate to New record	178
Navigate to New record with default values	179
Navigate to List view	180
Navigate to files	180
Navigate to record page in View & Edit Mode	182
Navigate to Tab	183
Navigate to record relationship page	184
Navigate to external web page	184
Navigate to LWC page	185
Navigate to Aura component	186
Navigate to VF page	188
Fetch current page reference	189
13)	WORK WITH SF DATA IN LWC	189
Base lightning components built on Lightning data service	192
Lightning-record-form	193
Lightning-record-view-form	198
Lightning-record-edit-form	200
Reset the Lightning-record-edit-form	201
Edit the Lightning-record-edit-form	201
Adding custom label to the fields in Lightning-record-edit-form	202
Custom validations in Lightning-record-edit-form	203
14)	LIGHTNING DATA SERVICE WIRE ADAPTORS AND FUNCTIONS	204
@wire service and fetch user details	206
getObjectInfo adapter	211
getObjectInfos adapter	213
getPicklistValues adapter	215
getPicklistValuesByRecordType adapter	217
getRecord adapter	220
getFieldValue & getFieldDisplayvalue functions	222
getRecordUi adapter	224
createRecord function	227
updateRecord function	229
deleteRecord function	232
getListUi adapter	234
getNavItems adapter	236
Life cycle of @wire Adopters	237
15)	APEX IN LWC	238
Expose Apex method to LWC	240
Import Apex methods	241
Wire Apex method	242
Wire Apex method with parameters	245
Call Apex method imperatively	246
Apex imperative method with parameters	249
16)	BOOKS LISTING APP WITH REST API CALLOUT	251
17)	COMPONENT CONFIGURATION IN LWC	252
Meta configuration in LWC	252
LWC in utility bar	255
LWC in lightning tab	256
18)	REAL TIME FEATURES	257
PDF generation in LWC	257
Charts in LWC	260
Maps in LWC	263
Filtering in LWC	265
Sorting in LWC	268
Reusable model component in LWC	271
Date validation	274
CSV generation in LWC	275
Custom Carousel using LWC	277
19)	TEST	282
20)	TEST	283





Important topics 
	
1)	Basics of HTML
	HTML describes the structure of the web page and HTML elements tell the browser how to display content. 
	Mostly used HTML elements in LWC.

 


 

Example: If we use <P> tag then it give one line break before and after the tag.
 

 


Example:
 


2)	Basics of CSS

 

 

HTML code:  If we want to link CSS with HTML then we need linkage CSS in HTL by using Link tag.

 

CSS code:

 

Result:
 

Types of CSS

 

To Use the Salesforce Lightning design System CSS styles In normal HTML file (if it is LWC component then this these classes will apply )we need to search CDNJS.com and then search for Lightning design System for the copy link tag and include in HTML by using Link tag. 
 



 

From this link all class are available to know the class name of any style which we need go to Lightning design System.com and then utilities from there we can find class name and use those class in the HTML.

 


CSS Box Model:
First content then padding will apply(space between content ) after that Border will finally margin(space b/w Browswer). 

 

Ex:  

Result:
 


3)	JavaScript for LWC


To use java script in HTML we need to use script tag under body tag with src name as file name of the Java script.

Ex: <body>
		<script  src =”./filename.js”> </script>
</body>

	Console.log is used display messages in Java script.

 

Variables
 

Function vs Block Scope
Before ES6, the only way you could declare a variable or a function in JavaScript was using the var keyword. You now have other options, and in this unit we go over why you want to use them.
To begin, let’s look a little closer at how variables are defined. Variables declared with the var keyword are said to be in the function scope. This means that a variable would exist only within the scope of the function in which it was declared. Or the nearest parent function, if it’s a nested function. 
That makes sense. And it still makes sense when you consider global scope, in which a variable is declared outside of a function. Take, for example, the following code.
var myVar = 1;
function myFunc() {
  var myVar = 2;
  console.log(myVar); 
}
myFunc();
console.log(myVar);
Copy
What numbers do you think you’d see in the console? 1 or 2?
You should see both. First 2 and then 1. Because of function scope, 2 is printed when the function is called. And because of global scope, 1 is displayed the second time, when the variable is written to the log outside the function.
Most developers get this, and everything is great until they encounter code containing an if statement, such as this example.
var myVar = 1;
if (true) {
  var myVar = 2;
  console.log(myVar);
}
console.log(myVar);
Copy
Now, what do you think will appear in the console? The same thing? 
Nope. Executing that code results in the number 2 appearing twice, because the fact that the var keyword does not support block scope. 
If you’re a developer coming from a different language, such as C++, C#, or Java, you may have learned a little something about block scope, and the last code example makes no sense to you. Don’t worry, you’re not alone—it has confused a lot of people.
A block is any code within curly braces. Block scoping ensures that any variables defined within those braces don’t become global variables. They instead have local scope. Having this type of control over how variables are scoped helps you prevent unexpected behaviour in your code. 


1)	var : It can be updated value and re-declare the value again. Var keyword supports Global scope(If we define var in the Global level we can use globally) and function scope(if we declare var key word within function then we can be able to use that within function only) and it doesn’t support block scope(even if we declare the var within block we can access outside of the block also).                 

In Below example , Course is declared Globally we use this anywhere, Onthercourse we define in function so it access within function only if try to access from outside then it will through error.
 



2)	let: this variable can be updated but can’t re-declared. let key word support function scope and block level scope and doesn’t support Global scope.   

Let Is the New Var
The lack of block scoping has caused many headaches for JavaScript developers, especially when it comes to variables declared in for loops. ES6 aimed to do away with all this unnecessary hardship by introducing the let keyword. 
Variables assigned with let are always block scoped. But this isn't the only benefit to using the let keyword. Variables assigned this way also cannot be hoisted. 

                                                                                                                                                                                           In below example, if we see let key word can update the value.if acess using Global scopre it’s showing undefined which means that it will not support Global scope, let keyword defined within functions or block only it will accessible if we try to access from outside it will through error.
 

3)	const: this variable can’t be updated but can’t re-declared. Cosnt  keyword support function scope and block level scope.

ES6 also introduced another keyword, const. You can probably guess what type of variable this defines—yep, it’s a constant. 
This can be useful when you need to declare a variable that cannot be redeclared or reassigned. Essentially, it’s read-only. If you declare a variable as a constant and then try to reassign it later in the code, it throws a type error. Variables declared with the const keyword are also block-scoped and cannot be hoisted, which you already learned is a good thing.
However, there are a couple of things to be aware of when using the const keyword. Since const values cannot be reassigned, they must be initialized at the time they are declared. If you tried to execute the following code, you would get an error telling you either unexpected token or that it was missing an initializer in the const declaration.
const BRANDCOLOR;
console.log(BRANDCOLOR);
Copy
 
And here is something that tends to trip up developers: Constants are not immutable. This means that it is possible to modify the properties of objects or arrays assigned with const. For example, if you declare an object such as this:
const BRANDCOLOR = {
  primary: "blue",
  accent: "teal"
}
Copy
You can execute the following code later on and the accent property will be reassigned without throwing an error.
BRANDCOLOR.accent = 'gray';
console.log(BRANDCOLOR);
Just don’t forget that when dealing with objects or arrays, only the object itself cannot be reassigned. Properties within that object or array can be changed.

Why Type the Same Thing Twice?
JavaScript developers are always trying to get data in and out of arrays or objects. More than likely, you have come across code like this, in which the properties of an object are initialized using variables:
let firstName = 'John', lastName = 'Doe';
let user = {
  firstName : firstName,
  lastName : lastName
}
console.log(user);
Copy
In ES6, you no longer have to repeat yourself, as long as the variables and object property names are the same. This code accomplishes the same thing:
let firstName = 'John', lastName = 'Doe';
let user = { firstName, lastName };
console.log(user); 
Copy
All we did here was remove the repeating variable names and colons ( : ). This shorthand comes in handy when you have objects containing a large number of fields. 


But that’s not all. ES6 provides a simpler way of getting data out of arrays or objects. This also helps reduce repetitive lines of code. Take for example an array that contains four numbers:
let numbers = [1, 2, 3, 4]; 
Copy
To get data out of this array, you can assign its values to variables like this:
let one = numbers[0],
  two = numbers[1],
  three = numbers[2],
  four = numbers[3];
console.log(one);  
Copy
You can now access the data through the variable names. So here the number 1 would be printed to the console. Even though this works, you might prefer to use a shortened method known as array destructuring.
let [one, two, three, four] = numbers;
console.log(one);
Copy
The brackets on the left side of the assignment are part of the new destructuring syntax. So, this code is the same thing as saying, “Give me four variables named one, two, three, and four, and assign the first value in the numbers array to variable one, the second value to variable two, and so on.” Shorter, sweeter, great. 
But now let’s say that you want to get just the third value, and you are not really interested in assigning variables to the first two elements. You can still use this syntax:
let [ , , three] = numbers;
Copy
We just used commas as placeholders for the first two elements, so variables aren’t created behind the scenes, and everything after the third position is ignored. It pretty much works the same way for objects, but instead of square brackets, you use curly braces. Consider this object:
const APPLE = {
  type: 'red delicious',
  color: 'red',
  size: 'large'
}
Copy
If you want to get data for the first two properties and then print out the second variable, you can do this.
const { type, color } = APPLE;
console.log(color);
Copy
One thing to keep in mind is that if you try to use the destructuring syntax with a variable name that does not exist, you get back “undefined.” For example, if you try to do the following, you’ll see undefined in the console.
const { type, color, size, packaging } = APPLE;
console.log(packaging);
Copy


Data Type

	If we include ‘n’ at end of any number then it will be bigint.  Typeof is method to tell what king of data type it is.
 

Example: 
Var x = 10
Console.log(typeof x) //number
Var y = 1035n
Console.log(typeof y) // bigint

Var obj = {}
Console.log(typeof y) // object

	If we declare within {} then it will treat as Object or if we declare within [] then it will consider as Array.
	If we declare a variable and not assigned any values then it will consider as Undefined.

 

As per documentation, type of null is also object.
 

Difference b/w Null vs Undefined
	If we declare a variable and not assigned any values then JS will consider as Undefined.
	If we want make any variable to empty or nothing we will use null.

Ex: 

Var x   ----: this is undefined. This one js will automatically intilized to Undefined.
Var y = 10
Y = null ----: This null . for this we need to explicitly assign as null.

 


==  this operator will check only value.
=== this operator will check value + data type.

 


Spread operator

 
Object data type is the key value combination. We can get the object value in 2 methods
Both will get the value in case of key have space in b/w charachers then we will use obj.[“key”] method.
See below example.
Obj.key
Obj[“key”]
 
	
 

	While combining the two objects using spread operator , if there any common keys available then left object keys will override with right side object.  In below example obj1 & Obj2 both have name and age properties when we try to merge these 2 objects with spread operator obj1 details will override with obj2 values.

 

	Existing problem before to the shallow copy by using spread operator. In below example we have array10 and it copied to array11. Now in array 11 am inserting new using push method after the new value will also inserted in to array10 because of these are referenced .

 
To avoid above issue we will shallow copy by using Spread operator. Shallow copy will work only at one level.

 
Destructuring

 

 
While we are destructing the Object we need to use same name of keys 
String Interpolation
By using ${} we can assign dynamic values in the strings. In string interpolation we will use back-ticks.(``)

 

Ex:
 

String Methods

 

	Indexof method  will return the staring position of the given word and it will return -1 if given string not exist. 
 

 
Trim method will remove the white spaces from both the sides.
 

Object/JSON operations
Mostly used operation are 
1)	Object.keys() : This method will return all keys in the array format.
2)	Object.values() : : This method will return all values in the array format.
3)	JSON.stringfy() : this method will convert object in to String.
4)	JSON.parse :  This method will convert string into object.
 




Array Methods

 

Syntax For the all methods:
Arrayname.methodname(function(currentitem, Index, actuvalarray){
})

Map():
 

Filter();
 

Every(): It will return true if every element in the array satisfy the condition else return false.
Some() :  It will return true if at least one element in the array satisfy the condition else return false.

 
Sort():  sorts in the ascending order.
To sort strings we apply sort() methods directly. If we want sort numbers we need to follow below logic, to return in descending order return b-a within function.
 
const points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return a-b});




Reduce(): for reduce method syntax will be differ.
 Syntax:  arraymane.reduce(function(total, currentitem, index, array){
})

Foreach()
 




Promise

 
For success:
 

For failure:
 

Fetching from server:

 

Modules Import and Export

To do import and export in HTML file we need add type as module like below.
<script type = “module” src = “./script.js” </script>

 

 

 
Export Multiple members and export default
 
Import :
 

Import all members from file:
 

Query selector

 
Once after quering the element from HTML like DIV or Id or Class we can apply the css for that particular element.
 
 
Event 

 

 

 
Once we click on the button then it will call firstfunction method.
 

Create a event by using addevenlistaner():
 

 

Even Propagation: In LWC, mainly event bubbling method will be used.
 
 
In below example if we click on the Para then onlick of para will execute after that form function and then div function will executed. In Event bubbling it from bottom to top. 
 

Custom event
 

Syntax: 
Let event = new customevent(“event name ”, detail:{parameters))
Document.dispatchevent(eventname)
Once event is fired we need to write event listener as well. Refer below code.

 


Arrow Function

 
In Arrow function we will use curly braces whenever we want perform dome data manipulation and then return value. See below code
 

In arrow function we want get only values directly then will not use curly braces. See below.

 

Problem solved by Arrow function:
If we created nested functions and within the nested functions some variable will not get the data.see below.
In below example within function name variable not able access to data so it’s printed as Undefined. 
 
We have resolved above issue with Arrow function,

 

Not use Arrow functions:
 
 


Set Timeout &Set Interval

 

 








4)	Introduction to LWC

 

 

Difference b/w  Aura & LWC:

	Aura build on the Es5 version but LWc supports all latest ES versions.
 


 

	Within Aura component we can include a LWC component but in LWC component we can’t include Aura comp.
 


 


 

Scratch max be available up to 30 days.
Dev Hub is main SF org.(Prod)
Sfdx commands it will give the all commands available in CLI.
 

 
Working with JavaScript
Here’s where you make stuff happen. As you’ve seen so far, JavaScript methods define what to do with input, data, events, changes to state, and more to make your component work.
The JavaScript file for a Lightning web component must include at least this code, where MyComponent is the name you assign your component class.
import { LightningElement } from 'lwc';
export default class MyComponent extends LightningElement {
}
Copy
The export statement defines a class that extends the LightningElement class. As a best practice, the name of the class usually matches the file name of the JavaScript class, but it’s not a requirement.
The LWC Module
Lightning Web Components uses modules (built-in modules were introduced in ECMAScript 6) to bundle core functionality and make it accessible to the JavaScript in your component file. The core module for Lightning web components is lwc.
Begin the module with the import statement and specify the functionality of the module that your component uses.
The import statement indicates the JavaScript uses the LightningElement functionality from the lwc module.
// import module elements
import { LightningElement} from 'lwc';
// declare class to expose the component
export default class App extends LightningElement {
    ready = false;
    // use lifecycle hook
    connectedCallback() {
        setTimeout(() => {
            this.ready = true;
        }, 3000);
    }
}
Copy
•	LightningElement is the base class for Lightning web components, which allows us to use connectedCallback().
•	The connectedCallback() method is one of our lifecycle hooks. You’ll learn more about lifecycle hooks in the next section. For now, know that the method is triggered when a component is inserted in the document object model (DOM). In this case, it starts the timer.

Lifecycle Hooks
Lightning Web Components provides methods that allow you to “hook” your code up to critical events in a component’s lifecycle. These events include when a component is:
•	Created
•	Added to the DOM
•	Rendered in the browser
•	Encountering errors
•	Removed from the DOM
Respond to any of these lifecycle events using callback methods. For example, the connectedCallback() is invoked when a component is inserted into the DOM. The disconnectedCallback() is invoked when a component is removed from the DOM.
In the JavaScript file we used to test our conditional rendering, we used the connectedCallback() method to automatically execute code when the component is inserted into the DOM. The code waits 3 seconds, then sets ready to true.
The this keyword in JavaScript refers to the top level of the current context. Here, the context is this class. The connectedCallback() method assigns the value for the top level ready variable.



5)	Fundamentals of LWC

Naming Conversion of your LWC component:

 

 
Component folder structure:

 

Different naming conventions available In LWC: 

 

 

Local Properties and Data binding
Property: In LWC, property is nothing but variable, obje, or arrays we created in JS is called properties. See below.
 

One way Data binding:  If we want to access property defined the controller (JS) in template(HTML) by using {propertyname}.
 

 
Two-way data binding: 

 
Methods:
HTML code: In HTML we applied SF standards CSS syles (Refer SLDS and get the class name refer DIV section in below) and Standard SF components( for Standard components refer Salesforce Component library in google). 

 
JS Code:
 

@api Decorator

•	@api: Marks a field as public. Public properties define the API for a component. An owner component that uses the component in its HTML markup can access the component’s public properties. All public properties are reactive, which means that the framework observes the property for changes. When the property’s value changes, the framework reacts and rerenders the component.
  Tip Field and property are almost interchangeable terms. A component author declares fields in a JavaScript class. An instance of the class has properties. To component consumers, fields are properties. In a Lightning web component, only fields that a component author decorates with @api are publicly available to consumers as object properties.


Track Property

@track: Tells the framework to observe changes to the properties of an object or to the elements of an array. If a change occurs, the framework rerenders the component. All fields are reactive. If the value of a field changes and the field is used in a template—or in the getter of a property used in a template—the framework rerenders the component. You don’t need to decorate the field with @track. Use @track only if a field contains an object or an array and if you want the framework to observe changes to the properties of the object or to the elements of the array. If you want to change the value of the whole property, you don’t need to use @track.
  Prior to Spring ’20, you had to use @track to mark fields (also known as private properties) as reactive. You’re no longer required to do that. Use @track only to tell the framework to observe changes to the properties of an object or to the elements of an array. Some legacy examples may still use @track where it isn’t needed, but that’s OK because using the decorator doesn’t change the functionality or break the code.
 
	If we are using object or array then any one of the values has changes then LWC framework by default will not track the changes to do that we need to use @track and also we ned to import Track from LWC . In below example whenever 
 

 


HTML code:
<template>
    <lightning-card title="Two way data binding">
        <div class="slds-var-m-around_medium">
            <lightning-input type="text"  label="Enter Course Name" onkeyup={changeHandler}>
            </lightning-input>
            <div>{fullname} is a course of {title}</div>
        </div>
    </lightning-card>

    <lightning-card title="@track properties">
        <div class="slds-var-m-around_medium">
            <lightning-input type="text" label="Enter City Name" onkeyup={trackHandler}>
            </lightning-input>
            <div>{address.city} is my City</div>
        </div>
    </lightning-card>   

</template>


JS code: In below code when we enter data in the normal fields it will capture data and updated in HTML file but when we change the data of array or object it’s not capturing and printing in HTML so for that we need o use @track to capture data change of array and objects.


import { LightningElement, track } from 'lwc';

export default class HelloWorld extends LightningElement {
    /***Data binding example */
    fullname="Zero To Hero"
    title ="aura"
    changeHandler(event){
        this.title = event.target.value
    }

    /***@track binding example */
   @track address={
        city:'Melbourne',
        postcode:3008,
        country:'Australia'
    }
    trackHandler(event){
        this.address.city = event.target.value
    }



Getters n LWC
It’s important in LWC and we will use frequently in LWC.
Problem: In below example we have a array and numbers in JS so if we want execute array expression or multiplication  in the template that was not allowed in LWC so we have requirement to do this. The solution we have is getters.  In below do the array expressions or calucations in JS itself and bind the result to template by using get key word before to the function.  Also getter always return some values.
 


HTML code:
<template>
    <lightning-card title="Two way data binding">
        <div class="slds-var-m-around_medium">
            <lightning-input type="text"  label="Enter Course Name" onkeyup={changeHandler}>
            </lightning-input>
            <div>{fullname} is a course of {title}</div>
        </div>
    </lightning-card>

    <lightning-card title="@track properties">
        <div class="slds-var-m-around_medium">
            <lightning-input type="text" label="Enter City Name" onkeyup={trackHandler}>
            </lightning-input>
            <div>{address.city} is my City</div>
        </div>
    </lightning-card>

    <lightning-card title="Getter Demo">
        <div class="slds-var-m-around_medium">
            <div>First username is {firstUser}</div>
            <div>Multiplication of {num1} and {num2} is {multiply}</div>
        </div>
    </lightning-card>
    

</template>


JS code:


import { LightningElement, track } from 'lwc';

export default class HelloWorld extends LightningElement {
    /***Data binding example */
    fullname="Zero To Hero"
    title ="aura"
    changeHandler(event){
        this.title = event.target.value
    }

    /***@track binding example */
   @track address={
        city:'Melbourne',
        postcode:3008,
        country:'Australia'
    }
    trackHandler(event){
        this.address.city = event.target.value
    }

    /***getter example */
    users = ["john", "smith", "nik"]
    num1 = 10
    num2 = 20
    // this.firstUser =this.users[0]
    get firstUser(){
        return this.users[0].toUpperCase()
    }

    get multiply(){
        return this.num1*this.num2
    }

}
Conditional Rendering


 
These If:true and If:false directives we can apply at Template level only.
 
 
 

HTML code:  in below code iw load page itially the Isvisible attribute is false in HTML IF:false block will execute once we click on the button then in JS it will updated as true then in HTML if:true will execute.

<template>
    <lightning-card title="Conditional rendering">
        <div class="slds-var-m-around_medium">
            <lightning-button 
            variant="brand"
            label="Show Data"
            title="Show Data" 
            onclick={handleClick}
            class="slds-var-m-left_x-small"></lightning-button>

            <template if:true={isVisible}>
                <div>Welcome to Zero to Hero series</div>
            </template>
            <template if:false={isVisible}>
                <div>You can't see the data. Please click the button</div>
            </template>

            <lightning-input 
            type="text"
            label="Type hello to see the data" onkeyup={changeHandler}>
            </lightning-input>
            <template if:true={helloMethod}>
                <div>Hurray!! You have typed correctly</div>
            </template>
            
        </div>
    </lightning-card>
</template>


JS code:

import { LightningElement } from 'lwc';

export default class HelloConditionalRendering extends LightningElement {
    isVisible = false
    name
    handleClick(){
        this.isVisible = true
    }

    changeHandler(event){
        this.name = event.target.value
    }

    get helloMethod(){
        return this.name === 'hello'
    }

}


Falsy values:

If the property have have any one this values and if we If:true directive it will be consider as false.

Ex: x= 0 , false, undefined, null , “”.



Template Looping in HTML

 
	In template Looping will only work on the Array. In Looping Key is mandatory to provide so the LWC engine can understand which items are changed.
Syntax: 
<template for:each{array} for:item = “current Item ” for:index= “index”> data </template>

 

 

	Iterator loop will be used whenever we requirement to apply some special action on First or Last item of the array.

Syntax: <template Iteratr:iteratorname={arrayname} > </template>.
 

 


HTML code:

<template>
    <lightning-card title="for:each loop">
        <div class="slds-var-m-around_medium">
            <template for:each={carList} for:item="car">
                <ul key={car} class="slds-has-dividers_around-space">
                    <li class="slds-item">{car}</li>
                </ul>
            </template>
        </div>
    </lightning-card>

    <lightning-card title="for:each loop with array of objects">
        <div class="slds-var-m-around_medium">
            <template for:each={ceoList} for:item="list">
                <ul key={list.id} class="slds-has-dividers_around-space">
                    <li class="slds-item">{list.name} {list.company}</li>
                </ul>
            </template>
        </div>
    </lightning-card>

    <lightning-card title="iterator loop">
        <div class="slds-var-m-around_medium">
            <template iterator:ceo={ceoList}>
                <div key={ceo.value.id}>
                    <ul class="slds-has-dividers_around-space">
                        <template if:true={ceo.first}>
                            <div class="slds-box slds-theme_shade">
                                <strong>
                                    List of top companies and there COE's
                                </strong>
                            </div>
                        </template>
                        
                        <li class="slds-item">
                            <strong>{ceo.value.company} </strong>
                            {ceo.value.name}
                        </li>

                        <template if:true={ceo.last}>
                            <div class="slds-box slds-theme_shade">
                                <strong>
                                    Thanks for reading the list
                                </strong>
                            </div>
                        </template>
                    </ul>
                </div>
               
            </template>
        </div>
    </lightning-card>


</template>


JS code:

import { LightningElement } from 'lwc';

export default class Looping extends LightningElement {
    carList =["Ford", "Audi", "Maruti", "Hyundai", "Mercedes"]

    ceoList = [
        {
            id:1,
            company:"Google",
            name:"Sundar Pichai"
        },
        {
            id: 2,
            company: "Apple Inc.",
            name: "Tim cook"
        },
        {
            id: 3,
            company: "Facebook",
            name: "Mark Zuckerberg"
        },
        {
            id: 4,
            company: "Amazon",
            name: "Jeff Bezos"
        },
    ]

}

Quiz App
HTML code
<template>
    <lightning-card title="Quiz App In LWC">
        <div class="slds-m-around_medium">
           
            <form>
                <template for:each={myQuestions} for:item="quiz">
                    <div key={quiz.id} class="slds-m-bottom_medium">
                        <div><strong>{quiz.id} - {quiz.question}</strong></div>
                        <div class="slds-grid slds-gutters slds-p-bottom_medium">
                            <div class="slds-col">
                                <input type="radio" name={quiz.id} value="a" onchange={changeHandler}/>
                                {quiz.answers.a}
                            </div>
                            <div class="slds-col">
                                <input type="radio" name={quiz.id} value="b" onchange={changeHandler}/>
                                {quiz.answers.b}
                            </div>
                            <div class="slds-col">
                                <input type="radio" name={quiz.id} value="c" onchange={changeHandler}/>
                                {quiz.answers.c}
                            </div>
                        </div>
                    </div>
                </template>
                <lightning-button 
                variant="brand" 
                type="submit"
                label="Submit"
                title="Submit Quiz"
                class="slds-m-around_small"
                disabled={allNotSelected}
                onclick={submitHandler}></lightning-button>
                <lightning-button 
                variant="brand" 
                type="reset"
                label="Reset"
                title="Reset Quiz"
                onclick={resetHandler}
                class="slds-m-around_small"></lightning-button>
            </form>
            <template if:true={isSubmitted}>    
                <div class={isScoredFull}>You have Scored {correctAnswers} out of {myQuestions.length}</div>
            </template>
        </div>
    </lightning-card>
</template>

JS code

import { LightningElement } from 'lwc';

export default class QuizApp extends LightningElement {

    selected={} // for storing answers
    correctAnswers = 0 //to show the number of correct answers
    isSubmitted = false // use to show the result
    myQuestions=[
        {
            id:"Question1",
            question:"Which one of the following is not a template loop?",
            answers:{
                a:"for:each",
                b:"iterator",
                c:"map loop"
            },
            correctAnswer:"c"
        },
        {
            id:"Question2",
            question:"Which of the file is invald in LWC component folder?",
            answers:{
                a:".svg",
                b:".apex",
                c:".js"
            },
            correctAnswer:"b"
        },
        {
            id:"Question3",
            question:"WHich one of the following is not a directive?",
            answers:{
                a:"for:each",
                b:"if:true",
                c:"@track"
            },
            correctAnswer:"c"
        }
    ]

    //used for disabling the sumbmit button
    get allNotSelected(){
        return !(Object.keys(this.selected).length === this.myQuestions.length)
    }

    // for applying dynamic styling to our result
    get isScoredFull(){
        return `slds-text-heading_large ${this.myQuestions.length === this.correctAnswers?
            'slds-text-color_success':'slds-text-color_error'}`
    }
    // changeHandler get's called on every click on the options
    changeHandler(event){
        const {name, value} = event.target 
        this.selected={...this.selected, [name]:value}
    }
    //form submit handler
    submitHandler(event){
        event.preventDefault()
        let correct = this.myQuestions.filter(item=>this.selected[item.id] === item.correctAnswer)
        this.correctAnswers = correct.length
        this.isSubmitted = true
    }
    //form reset handler
    resetHandler(){
        this.selected ={}
        this.correctAnswers=0
        this.isSubmitted = false
    }
}


Component Composition
	Composition is adding component within the body of another component.
	Whenever we exposing to salesforce no need to expose child component separately. Once we exposed parent component then it take required data from child component.(Refer Video40 at 5min .45 sec)
	

 

	

Parent HTML
<template>
    <lightning-card title="Parent Component">
        <div class="slds-var-m-around_medium">
            <h1>Hello from parent component</h1>
            <c-hello-child-component></c-hello-child-component>
        </div>
    </lightning-card>
</template>

Child HTML:
<template>
    <lightning-card title="Child Component">
        <div class="slds-var-m-around_medium">
            <h1>Hello from child component</h1>
        </div>
    </lightning-card>
</template>

Shadow DOM 


 
Normally shadow will be available in child component so in whatever CSS applied n parent will not be applied to child directly we need to apply seperatly. We can’t access child component properties directly in Parent comp because of shadow DOM, there are some other ways to access it.
  

Shadow DOM is a standard that encapsulates the internal document object model (DOM) structure of a web component. Encapsulating the DOM gives developers the ability to share a component and protect the component from being manipulated by arbitrary HTML, CSS, and JavaScript. The internal DOM structure is called the shadow tree. The shadow tree affects how you work with CSS, events, and the DOM.
Since not all browsers that Salesforce supports implement Shadow DOM, LWC uses a shadow DOM polyfill. A polyfill is code that allows a feature to work in a web browser.
To understand the shadow tree, let’s look at some markup. This markup contains two Lightning web components: c-todo-app and c-todo-item. The #shadow-root document fragment defines the boundary between the DOM and the shadow tree. Elements below the shadow root are in the shadow tree.
<c-todo-app>
  #shadow-root
    <div>
        <p>Your To Do List</p>
    </div>
    <c-todo-item>
      #shadow-root
        <div>
            <p>Go to the store</p>
        </div>
    </c-todo-item>
</c-todo-app>
Let’s look at how to work with the shadow tree in each of these areas.
CSS
CSS styles defined in a parent component don’t leak into a child. In our example, a p style defined in the todoApp.css style sheet doesn’t style the p element in the c-todo-item component, because the styles don’t reach into the shadow tree. See CSS.
Events
To prevent exposing a component’s internal details, if an event bubbles up and crosses the shadow boundary, some property values change to match the scope of the listener. See Event Retargeting in Handle Events.
Access Elements
Elements in a shadow tree aren’t accessible via traditional DOM querying methods. Code can’t use document or document.body to access the shadow tree of a Lightning web component. For example, code can’t call document.querySelector() to select nodes in a Lightning web component’s shadow tree. To access its own shadow tree, a Lightning web component calls this.template.querySelector(). See Access Elements the Component Owns.
Access Slots
A slot is a placeholder for markup that a parent component passes into a component’s body. DOM elements that are passed to a component via slots aren’t owned by the component and aren’t in the component’s shadow tree. To access DOM elements passed via slots, call this.querySelector(). The component doesn't own these elements, so you don’t use template.




Accessing elements in the Components
By using this.template it will fetch the details from the current component.

 


HTML code:
<template>
    <lightning-card title="querySelector">
        <div class="slds-var-m-around_medium">
            <h1>Hey I am heading</h1>
            <template for:each={userNames} for:item="user">
                <div class="name" key={user}>{user}</div>
            </template>
            <div class="child" lwc:dom="manual"></div>
             <button onclick={fetchDetailHandler}>Fetch details</button>
        </div>
    </lightning-card>
</template>


JS code:
import { LightningElement } from 'lwc';

export default class HelloQuerySelectorDemo extends LightningElement {
    userNames =["John", "Smith", "Nik", "Mike"]
    fetchDetailHandler(){
        const elem = this.template.querySelector('h1')
        elem.style.border="1px solid red";
        console.log(elem.innerText)
        const userElements = this.template.querySelectorAll('.name')
        Array.from(userElements).forEach(item=>{
            console.log(item.innerText)
            item.setAttribute("title", item.innerText)
        })

        ///  lwc:dom="manual" demo
        const childElem = this.template.querySelector('.child')
        childElem.innerHTML = '<p>Hey i am a child element</p>'
    }
}


6)	Styling in LWC

We can apply CSS in LWC as many ways mentioned in below.


 



Inline and External CSS

	When we apply styling within HTML tags by using Style its called as Inline styling and it’s not recommended way.
Ex: <div style= “colour:red” > </div>
	To apply external style we need to create CSS file same as component name.
SF doesn’t recommend to apply CSS on ID, it’s recommended to apply on element, class , pseudo.

HTML code:
<template>
    <lightning-card title="inline styling">
        <div class="slds-m-around_medium">
            <div style="color:red; font-size:20px;">Hello i am div tag</div>
        </div>
    </lightning-card>
    <lightning-card title="External styling">
        <div class="slds-m-around_medium">
           <p>Hey i am a p Tag</p>
           <div class="user">Zero to hero</div>
        </div>
    </lightning-card>
</template>

CSS code:

/* element, classes, pseudo */
p{
    color:green;
    font-size: 30px;
    border: 1px solid red;;
}
.user{
    color:pink;
    font-size: 20px;
}
//Hover property will execute whenever we moved the cursor on browse on the class this styles will apply
.user:hover{
    font-size: 50px;
    color:red;
}


Lightning Design system

 
HTML code

<template>
    <lightning-card title="SLDS demo">
        <div class="slds-p-horizontal_medium">
            <div class="slds-box">
                <p>This is a regular-sized box.</p>
                <span class="slds-badge">Badge Label</span>
                <span class="slds-badge slds-theme_success">Success Label</span>
                <div class="slds-text-heading_large">The quick brown fox jumps over the lazy dog.</div>
            </div>
            <div class="slds-grid slds-gutters">
                <div class="slds-col slds-size_8-of-12">
                    <span>1</span>
                </div>
                <div class="slds-col slds-size_4-of-12">
                    <span>2</span>
                </div>
            </div>
        </div>
        
    </lightning-card>
    <lightning-card>
        <div class="slds-brand-band slds-brand-band_medium slds-brand-band_group"></div>
    </lightning-card>
    
</template>


SLDS Design token

In SLDS web site we have design tokens also these can help us to avoid hardcoding value like clour blue extra instaed of ths we can use standard SF design tokens. See below example.
HTML code:
<template>
    <div>Hello Everyone</div>
</template>

CSS: In below instead of hard coding we referring SLDS design token and using in CSS file.

div{
    color:var(--lwc-brandAccessible);
    background:var(--lwc-colorBackgroundAlt);
}

Shared CSS
Suppose we have multiple components and we want apply same CSS to all components then we need to create CSS file for each component with component name in normal case. So to avoid writing same code  multiple CSS file to apply same style for multiple components we will use Shared CSS.
Create a one new component and in that CSS add our code then import this css in each CSS file with below syntax so that these styles will apply to your code. Refer below examples.

Syntax: @import ‘c/sharedCSSfilename’

So some time we made changes in one component and tried to deploy sometimes it will through error like @imoprt CSS file not exist. To resolve this error just edit the Shared CSS file and try to deploy.

Comp1 HTML
<template>
    <lightning-card title="style one">
        <div class="slds-var-m-around_medium">
            <div class="wrapper">
                <div class="skills css">80%</div>
            </div>
        </div>
    </lightning-card>
</template>

Comp1 CSS

@import 'c/cssLibrary';

.css{
    width:80%;
    background-color: #2196f3;
}

Comp2 HTML

<template>
    <lightning-card title="style two">
        <div class="slds-var-m-around_medium">
            <div class="wrapper">
                <div class="skills html">90%</div>
            </div>
        </div>
    </lightning-card>
</template>

Comp2 CSS

@import 'c/cssLibrary';
.html{
    width:90%;
    background-color: #4caf50;
}
.abc{
    color:red;
}

Shared CSS file:

.wrapper{
    width:100%;
    background-color: #ddd;
}
.skills{
    text-align: right;
    padding-top:10px;
    padding-bottom:10px;
    color:white;
}


Dynamic Styling

We can apply CSS dynamically. See below example. In below example width style will apply dynamically on entering the input field.

HTML code:
<template>
    <lightning-card title="Dynamic CSS">
        <div class="slds-var-m-around_medium">
            <lightning-input type="number" value={percent} label="Percentage" 
            onkeyup={changeHandler}></lightning-input>
            <div style={percentage} class="slds-notify slds-notify_alert slds-theme_alert-texture slds-theme_error" role="alert">
                Hey i am an ALERT!!!
            </div>
        </div>
    </lightning-card>
</template>

CSS
import { LightningElement } from 'lwc';

export default class DynamicCss extends LightningElement {
    percent = 10
    changeHandler(event){
        this.percent = event.target.value
    }
   get percentage(){
        return `width:${this.percent}%`
    }
}


Styling Across shadow DOM

This is not a recommended way it will reduce performance. If we don’t have any other option then use this.
In below example Lightning button is the standard one if we try apply styling normally it will not apply to do that we need to implement logic as it is in JS.
HTML code:
<template>
    <lightning-card title="CSS across Shadow DOM">
        <div class="slds-var-m-around_medium">
            <lightning-button label="testing" title="testing" class="btn"></lightning-button>
        </div>
    </lightning-card>
</template>

JS
import { LightningElement } from 'lwc';

export default class ShadowDomStyling extends LightningElement {
    isLoaded = false
    renderedCallback(){
        if(this.isLoaded) return
        const style = document.createElement('style')
        style.innerText = `c-shadow-dom-styling .slds-button{
            background: red;
            color: white;
        } `
        this.template.querySelector('lightning-button').appendChild(style)
        this.isLoaded = true
    }
}


7)	Component Life Cycle Hooks

    
 


Life Cycle Hooks in mounting phase


 

 
Constructor ():
In this properties are not ready in this method if we see above diagram properties will ready after the constructor method().

 

Connected Callback ():
In this method, we can call the Apex methods to load the data in the component.
 

Rendered Callback ():
	We need to use this method very carefully otherwise, it will reduce performance.  this method will call again and again whenever there is HTML rendered(Like changes in HTML i.e entering input in html, onchange events extras)

 

Parent HTML

<template>
    <lightning-card title="Lifecycle hook parent card">
        <div class="slds-var-m-around_medium">
                 <input type="text" onkeyup={changeHandler}/>
                 {name}
                <c-life-cycle-child></c-life-cycle-child>
            
        </div>
    </lightning-card>

</template>
Parent JS

import { LightningElement } from 'lwc';

export default class LifeCycleParent extends LightningElement {
    isChildVisible = false
    constructor(){ 
        super()
        console.log("parent constructor called")
    }
    connectedCallback(){ 
        console.log("parent connectedCallback called")
    }
    renderedCallback(){ 
        console.log("parent renderedCallback called")
    }

    name
    changeHandler(event){
        this.name = event.target.value
    }

   
}

Child HTML
<template>
    <lightning-card title="Lifecycle hook Child card">
        <div class="slds-var-m-around_medium">
            
        </div>
    </lightning-card>
</template>

Child JS

import { LightningElement } from 'lwc';

export default class LifeCycleChild extends LightningElement {
    constructor(){ 
        super()
        console.log("Child constructor called")
    }
    connectedCallback(){ 
        console.log("Child connectedCallback called")
        throw new Error('Loading of child component failed')
    }
    renderedCallback(){ 
        console.log("Child renderedCallback called")
    }

}

Life cycle hooks in Unmounting phase
Disconnected Callback (); this method is very important to avoid the memory leaks issue. This method will fire when we remove component from the DOM.
This can used whenever we used add lis
 


Parent HTML
<template>
    <lightning-card title="Lifecycle hook parent card">
        <div class="slds-var-m-around_medium">
            <template if:true={isChildVisible}>
                <lightning-button
                variant="brand"
                label="Remove Child" 
                title="Remove Child" 
                onclick={handleClick} 
                class="slds-m-left_x-small"></lightning-button>
            </template>
            <template if:false={isChildVisible}>
                <lightning-button
             variant="brand"
             label="Show Child" 
             title="Show Child" 
             onclick={handleClick} 
             class="slds-m-left_x-small"></lightning-button>
            </template>
             <template if:true={isChildVisible}>
                <c-life-cycle-child></c-life-cycle-child>
             </template>
            
        </div>
    </lightning-card>

</template>


Parent JS
import { LightningElement } from 'lwc';

export default class LifeCycleParent extends LightningElement {
    isChildVisible = false
    constructor(){ 
        super()
        console.log("parent constructor called")
    }
    connectedCallback(){ 
        console.log("parent connectedCallback called")
    }
    renderedCallback(){ 
        console.log("parent renderedCallback called")
    }

    handleClick(){ 
        this.isChildVisible = !this.isChildVisible
    }
}

Child HTML
<template>
    <lightning-card title="Lifecycle hook Child card">
        <div class="slds-var-m-around_medium">
            
        </div>
    </lightning-card>
</template>

Child JS

import { LightningElement } from 'lwc';

export default class LifeCycleChild extends LightningElement {
    constructor(){ 
        super()
        console.log("Child constructor called")
    }
    connectedCallback(){ 
        console.log("Child connectedCallback called")
    }
    renderedCallback(){ 
        console.log("Child renderedCallback called")
    }
    disconnectedCallback(){
       alert('Child disconnectedCallback called !!') 
    }

}
Error Phase
Error Callback():

 

Parent HTML:
<template>
    <lightning-card title="Lifecycle hook parent card">
        <div class="slds-var-m-around_medium">
            <template if:true={isChildVisible}>
                <lightning-button
                variant="brand"
                label="Remove Child" 
                title="Remove Child" 
                onclick={handleClick} 
                class="slds-m-left_x-small"></lightning-button>
            </template>
            <template if:false={isChildVisible}>
                <lightning-button
             variant="brand"
             label="Show Child" 
             title="Show Child" 
             onclick={handleClick} 
             class="slds-m-left_x-small"></lightning-button>
            </template>
             <template if:true={isChildVisible}>
                <c-life-cycle-child></c-life-cycle-child>
             </template>
            
        </div>
    </lightning-card>

</template>

Parent JS:
import { LightningElement } from 'lwc';

export default class LifeCycleParent extends LightningElement {
    isChildVisible = false
    constructor(){ 
        super()
        console.log("parent constructor called")
    }
    connectedCallback(){ 
        console.log("parent connectedCallback called")
    }
    renderedCallback(){ 
        console.log("parent renderedCallback called")
    }

    handleClick(){ 
        this.isChildVisible = !this.isChildVisible
    }

    errorCallback(error, stack){ 
        console.log(error.message)
        console.log(stack)
    }
}

Child HTML:
<template>
    <lightning-card title="Lifecycle hook Child card">
        <div class="slds-var-m-around_medium">
            
        </div>
    </lightning-card>
</template>

Child JS:
import { LightningElement } from 'lwc';

export default class LifeCycleChild extends LightningElement {
    constructor(){ 
        super()
        console.log("Child constructor called")
    }
    connectedCallback(){ 
        console.log("Child connectedCallback called")
        throw new Error('Loading of child component failed')
    }
    renderedCallback(){ 
        console.log("Child renderedCallback called")
    }
    disconnectedCallback(){
       alert('Child disconnectedCallback called !!') 
    }

}



Render Method

 

 

Signin HTML:
<template>
    <lightning-card title="Render Multiple Template" icon-name="custom:custom14">
        <div class="slds-var-m-around_medium">
            <h2 class="slds-text-heading_medium slds-var-m-bottom_medium">Signin Form</h2>
            <lightning-input type="email" label="Email Address"></lightning-input>
            <lightning-input type="password" label="Password"></lightning-input>
            <lightning-button
            variant="destructive"
            label="back"
            title="back"
            onclick={handleClick}
            class="slds-m-left_x-small"></lightning-button>
            <lightning-button
            variant="success"
            label="Signin"
            title="Signin"
            onclick={submitHandler}
            class="slds-m-left_x-small"></lightning-button>
        </div>
    </lightning-card>
</template>

Signup HTML:
<template>
    <lightning-card title="Render Multiple Template" icon-name="custom:custom14">
        <div class="slds-var-m-around_medium">
            <h2 class="slds-text-heading_medium slds-var-m-bottom_medium">Signup Form</h2>
            <lightning-input type="text" label="First Name"></lightning-input>
            <lightning-input type="text" label="Last Name"></lightning-input>
            <lightning-input type="email" label="Email Address"></lightning-input>
            <lightning-input type="password" label="Password"></lightning-input>
            <lightning-button
            variant="destructive"
            label="back"
            title="back"
            onclick={handleClick}
            class="slds-m-left_x-small"></lightning-button>
            <lightning-button
            variant="success"
            label="Signup"
            title="Signup"
            onclick={submitHandler}
            class="slds-m-left_x-small"></lightning-button>
        </div>
    </lightning-card>
</template>

Renderd HTML:

<template>
    <lightning-card title="Render Multiple Template" icon-name="custom:custom14">
        <div class="slds-var-m-around_medium">
            <h2 class="slds-text-heading_medium slds-var-m-bottom_medium">Choose your option</h2>
            <lightning-button
            variant="destructive"
            label="Signup"
            title="Signup"
            onclick={handleClick}
            class="slds-m-left_x-small"></lightning-button>
            <lightning-button
            variant="success"
            label="Signin"
            title="Signin"
            onclick={handleClick}
            class="slds-m-left_x-small"></lightning-button>
        </div>
    </lightning-card>
</template>


Renderd  JS:

import { LightningElement } from 'lwc';
import signinTemplate from './signinTemplate.html'
import signupTemplate from './signupTemplate.html'
import renderTemplate from './renderMethod.html'
export default class RenderMethod extends LightningElement {
    selectedBtn=''
    render(){ 
        return this.selectedBtn === 'Signup' ? signupTemplate :
                this.selectedBtn === 'Signin' ? signinTemplate:
                renderTemplate
    }

    handleClick(event){ 
        this.selectedBtn = event.target.label
    }
    submitHandler(event){ 
        console.log(`${event.target.label} Successfully!!`)
    }
}



8)	Component Communication



We have multiple ways to communicate b/w components.
1)	Parent to child communication
2)	Child to parent communication
3)	Sibling component communication using Pubsub
4)	Communication across VF, Aura and LWC using Lightning Message service



 




Parent to child communication
We have 4 types of parent to child communication.
1)	Parent to child communication using Primitive data type
2)	Parent to child communication using Non-Primitive data type
3)	Parent to child communication On action at Parent component
4)	Calling child method from parent component


 

Parent to child communication using Primitive data type
Once me make field public then only child component can access those fields/properties or methods so to make a field /property or method public, we need to use @api decorator and we need to import API from LWC package.

We will use @api decorator in Child component and will pass value from parent in the form of Attribute, refer in example code ‘message’ keyword.
 

 

Parent HTML:  From parent HTML we are passing string in attributes of Child component insertion and in child component we making @api for this in JS and using that property in Child HTML.
While passing Boolean values in HTML attributes and not initialized any values then by default it will consider as ‘true’. Refer ‘is-Valid’ in below example.

<template>
    <c-p2c-alert-component
    message="Hurray !! I got the data"
    card-heading="Parent to Child primitive data communication"
    number=20
    is-valid
    ></c-p2c-alert-component>
</template>

Parent JS
import { LightningElement } from 'lwc';

export default class P2cParentComponent extends LightningElement {
    
}


Child HTML

<template>
    <lightning-card title={cardHeading}>
        <div class="slds-notify_alert slds-theme_error" role="alert">
            {number} {message} {isValid}
        </div>
    </lightning-card>
</template>

Child JS
import { LightningElement, api } from 'lwc';

export default class P2cAlertComponent extends LightningElement {
    @api message
    @api cardHeading
    @api number
    @api isValid
}


Parent to child communication using Non-Primitive data type

 

Parent HTML

<template>
    <c-p2c-alert-component
    message="Hurray !! I got the data"
    card-heading="Parent to Child primitive data communication"
    number=20
    is-valid
    ></c-p2c-alert-component>

    <div class="slds-var-m-bottom_medium"></div>
    <c-p2c-carousel-component carousel-details={carouselData}></c-p2c-carousel-component>
</template>
Parent JS:
import { LightningElement } from 'lwc';

export default class P2cParentComponent extends LightningElement {
    carouselData=[
        {
            src:"https://www.lightningdesignsystem.com/assets/images/carousel/carousel-01.jpg",
            header:"First Card",
            description:"First Description"
        },
        {
            src:"https://www.lightningdesignsystem.com/assets/images/carousel/carousel-02.jpg",
            header:"Second Card",
            description:"Second Description"
        },
        {
            src:"https://www.lightningdesignsystem.com/assets/images/carousel/carousel-03.jpg",
            header:"Third Card",
            description:"Third Description"
        }
    ]
}

Child HTML

<template>
    <lightning-card title="Parent to Child non-primitive data communication">
        <div class="slds-var-m-around_medium">
            <lightning-carousel disable-auto-scroll>
                <template for:each={carouselDetails} for:item="item">
                    <lightning-carousel-image
                    key={item.header}
                    src ={item.src}
                    header ={item.header}
                    description ={item.description}>
                </lightning-carousel-image>
                </template>
                
            </lightning-carousel>
        </div>
    </lightning-card>
    
</template>

Child JS
import { LightningElement, api } from 'lwc';

export default class P2cCarouselComponent extends LightningElement {
    @api carouselDetails
}


Parent to child communication On action at Parent component

In this way data can be transferred from parent to child when performed any actions like onchange, click.

 

Parent HTML

<template>
    <!---Example of Simple Data-->
    <c-p2c-alert-component
    message="Hurray !! I got the data"
    card-heading="Parent to Child primitive data communication"
    number=20
    is-valid
    ></c-p2c-alert-component>

     <!---Example of Complex Data-->
    <div class="slds-var-m-bottom_medium"></div>
    <c-p2c-carousel-component
     carousel-details={carouselData}>
    </c-p2c-carousel-component>

    <!---Example of data passing on action-->
    <div class="slds-var-m-bottom_medium"></div>
    <lightning-card title="Parent to Child communication on action">
        <div class="slds-var-m-around_medium">
            <lightning-input type="number"
             label="Enter percentage"
             onkeyup={changeHandler}
             value={percentage}
             ></lightning-input>
             
             <c-p2c-progress-component
             progress-value={percentage}
             ></c-p2c-progress-component>
        </div>
    </lightning-card>
    
</template>

Parent JS:

import { LightningElement } from 'lwc';

export default class P2cParentComponent extends LightningElement {
    carouselData=[
        {
            src:"https://www.lightningdesignsystem.com/assets/images/carousel/carousel-01.jpg",
            header:"First Card",
            description:"First Description"
        },
        {
            src:"https://www.lightningdesignsystem.com/assets/images/carousel/carousel-02.jpg",
            header:"Second Card",
            description:"Second Description"
        },
        {
            src:"https://www.lightningdesignsystem.com/assets/images/carousel/carousel-03.jpg",
            header:"Third Card",
            description:"Third Description"
        }
    ]

    percentage=10
    changeHandler(event){
        this.percentage = event.target.value
    }
}

Child HTML

<template>
    <lightning-progress-bar value={progressValue} size="large"></lightning-progress-bar>
</template>

Child JS

import { LightningElement, api } from 'lwc';

export default class P2cProgressComponent extends LightningElement {
    @api progressValue
}

Calling child method from parent component

 


Parent HTML
<template>
    <!---Example of Simple Data-->
    <c-p2c-alert-component
    message="Hurray !! I got the data"
    card-heading="Parent to Child primitive data communication"
    number=20
    is-valid
    ></c-p2c-alert-component>

     <!---Example of Complex Data-->
    <div class="slds-var-m-bottom_medium"></div>
    <c-p2c-carousel-component
     carousel-details={carouselData}>
    </c-p2c-carousel-component>

    <!---Example of data passing on action-->
    <div class="slds-var-m-bottom_medium"></div>
    <lightning-card title="Parent to Child communication on action">
        <div class="slds-var-m-around_medium">
            <lightning-input type="number"
             label="Enter percentage"
             onkeyup={changeHandler}
             value={percentage}
             ></lightning-input>

             <c-p2c-progress-component
             progress-value={percentage}
             ></c-p2c-progress-component>
        </div>
    </lightning-card>

    <!---Example of Calling child Method from parent-->
    <lightning-button variant="brand" label="Reset Slider"
    onclick={handleClick}></lightning-button>
    <c-p2c-slider-component></c-p2c-slider-component>
</template>

Parent JS:

import { LightningElement } from 'lwc';

export default class P2cParentComponent extends LightningElement {
    carouselData=[
        {
            src:"https://www.lightningdesignsystem.com/assets/images/carousel/carousel-01.jpg",
            header:"First Card",
            description:"First Description"
        },
        {
            src:"https://www.lightningdesignsystem.com/assets/images/carousel/carousel-02.jpg",
            header:"Second Card",
            description:"Second Description"
        },
        {
            src:"https://www.lightningdesignsystem.com/assets/images/carousel/carousel-03.jpg",
            header:"Third Card",
            description:"Third Description"
        }
    ]

    percentage=10
    changeHandler(event){
        this.percentage = event.target.value
    }

    handleClick(){
//to call method of the child com we need to take reference of that comp by using query selector and then call method
        this.template.querySelector('c-p2c-slider-component').resetSlider()
    }
}

Child HTML
<template>
    <lightning-card title="Calling child method from parent">
        <div class="slds-var-m-around_medium">
            <lightning-slider label="Volume" value={val} onchange={changeHandler}></lightning-slider>
        </div>
    </lightning-card>
</template>

Child JS

import { LightningElement, api } from 'lwc';

export default class P2cSliderComponent extends LightningElement {
    val = 20
    changeHandler(event){ 
        this.val = event.target.value
    }
//in below we are exposing method as public.
    @api resetSlider(){ 
        this.val = 50
    }
}


Child to Parent communication
Child to parent communication we have 3 types.
1)	Child to parent communication using simple event
2)	Child to parent using communication using event with data
3)	Child to parent communication using event bubbling 


 


Child to parent communication using simple event

Create event and dispatch events.
 
Parent HTML
<template>
    <lightning-card title="Child to parent communication">
        <div class="slds-var-m-around_medium">
            <lightning-button label="Show Modal" 
            onclick={clickHandler}></lightning-button>

            <template if:true={showModal}>
                <c-c2p-modal-component 
                onclose={closeHandler}    (here we need to give method name as on + event name of child)
                ></c-c2p-modal-component>
            </template>
           
        </div>
    </lightning-card>
</template>

Parent JS:
import { LightningElement } from 'lwc';

export default class C2pParentComponent extends LightningElement {
    showModal = false
    clickHandler(){ 
        this.showModal = true
    }
    closeHandler(){ 
        this.showModal = false
    }
}

Child HTML
<template>
    <section role="dialog" tabindex="-1" class="slds-modal slds-fade-in-open slds-modal_small" aria-labelledby="modal-heading-01" aria-modal="true" aria-describedby="modal-content-id-1">
        <div class="slds-modal__container">
        <header class="slds-modal__header">
            <h2 id="modal-heading-01" class="slds-modal__title slds-hyphenate">Confirmation</h2>
        </header>
        <div class="slds-modal__content slds-p-around_medium" id="modal-content-id-1">
            <p>Successfully Created!!</p>
        </div>
        <footer class="slds-modal__footer">
            <button class="slds-button slds-button_brand" onclick={closeHandler}>Ok</button>
        </footer>
        </div>
    </section>
        <div class="slds-backdrop slds-backdrop_open"></div>
</template>

Child JS
import { LightningElement } from 'lwc';

export default class C2pModalComponent extends LightningElement {

    closeHandler(){ 
// here we creating the even and dispatching this can be recived at where ever child compont used there they can able access by using on + event name. In this parent html, same way the chils comp is used in some other componet there also same way it cann access it.
        const myEvent = new CustomEvent('close')
        this.dispatchEvent(myEvent)
    }
}


Child to parent using communication using event with data
If we want pass the data along with event we need to use details while creating the event. See below code.

Parent HTML
<template>
    <lightning-card title="Child to parent communication">
        <div class="slds-var-m-around_medium">
            <lightning-button label="Show Modal" 
            onclick={clickHandler}></lightning-button>
            <h1>{msg}</h1>
            <template if:true={showModal}>
                <c-c2p-modal-component 
                onclose={closeHandler}
                ></c-c2p-modal-component>
            </template>
           
        </div>
    </lightning-card>
</template>

Parent JS:
import { LightningElement } from 'lwc';

export default class C2pParentComponent extends LightningElement {
    showModal = false
    msg
    clickHandler(){ 
        this.showModal = true
    }
    closeHandler(event){ 
        this.msg = event.detail.msg
        this.showModal = false
    }
}

Child HTML

<template>
    <section role="dialog" tabindex="-1" class="slds-modal slds-fade-in-open slds-modal_small" aria-labelledby="modal-heading-01" aria-modal="true" aria-describedby="modal-content-id-1">
        <div class="slds-modal__container">
        <header class="slds-modal__header">
            <h2 id="modal-heading-01" class="slds-modal__title slds-hyphenate">Confirmation</h2>
        </header>
        <div class="slds-modal__content slds-p-around_medium" id="modal-content-id-1">
            <p>Successfully Created!!</p>
        </div>
        <footer class="slds-modal__footer">
            <button class="slds-button slds-button_brand" onclick={closeHandler}>Ok</button>
        </footer>
        </div>
    </section>
        <div class="slds-backdrop slds-backdrop_open"></div>
</template>

Child JS
import { LightningElement } from 'lwc';

export default class C2pModalComponent extends LightningElement {

    closeHandler(){ 
        const myEvent = new CustomEvent('close', { 
            detail: { 
                msg:"Modal Closed Successfully!!"
            }
        })
        this.dispatchEvent(myEvent)
    }
}

Child to parent communication using event bubbling 

In this model child event will trigger at <P> then it will execute upper tags actins like dive and extra and then it will go to parent there also it will execute from lower t Higher. This will use very rarely.


 

Parent HTML
<template>
    <lightning-card title="Child to parent communication">
        <div class="slds-var-m-around_medium" onclose={closeHandler}>
            <lightning-button label="Show Modal" 
            onclick={clickHandler}></lightning-button>
            <h1>{msg}</h1>
            <template if:true={showModal}>
                <c-c2p-modal-component 
                ></c-c2p-modal-component>
            </template>
           
        </div>
    </lightning-card>
</template>

Parent JS:

import { LightningElement } from 'lwc';

export default class C2pParentComponent extends LightningElement {
    showModal = false
    msg
    clickHandler(){ 
        this.showModal = true
    }
    closeHandler(event){ 
        this.msg = event.detail.msg
        this.showModal = false
    }
}


Child HTML

<template>
    <section role="dialog" tabindex="-1" class="slds-modal slds-fade-in-open slds-modal_small" aria-labelledby="modal-heading-01" aria-modal="true" aria-describedby="modal-content-id-1">
        <div class="slds-modal__container">
        <header class="slds-modal__header">
            <h2 id="modal-heading-01" class="slds-modal__title slds-hyphenate">Confirmation</h2>
        </header>
        <div class="slds-modal__content slds-p-around_medium" id="modal-content-id-1">
            <p>Successfully Created!!</p>
        </div>
        <footer class="slds-modal__footer" onclick={footerHandler}>
            <button class="slds-button slds-button_brand" onclick={closeHandler}>Ok</button>
        </footer>
        </div>
    </section>
        <div class="slds-backdrop slds-backdrop_open"></div>
</template>

Child JS
import { LightningElement } from 'lwc';

export default class C2pModalComponent extends LightningElement {

    closeHandler(){ 
        const myEvent = new CustomEvent('close', { 
            bubbles:true,
            detail: { 
                msg:"Modal Closed Successfully!!"
            }
        })
        this.dispatchEvent(myEvent)
    }

    footerHandler(){ 
        console.log("footerHandler called")
    }
}



Sibling component communication using Pubsub

This is old method to communicate independent comp, now days not using much. Use this approach in case lightning message system not serve your requirement.
   
 

Comp A HTML:  In this component we are publish the event by click the publish button and entering some data to publish.
<template>
    <lightning-card title="Pubsub demo Component A">
        <div class="slds-p-around_medium">
            <lightning-input type="text" onkeyup={inputHandler} class="slds-m-bottom_medium"></lightning-input>
            <lightning-button variant="brand" onclick={publishHandler} label="publish"></lightning-button>
        </div>
    </lightning-card>
</template>

Comp a JS : In publish handler it will call indivual  JS to publish the Message.

import { LightningElement } from 'lwc';
import pubsub from 'c/pubsub'
export default class PubsubComponentA extends LightningElement {
    message
    inputHandler(event){
        this.message = event.target.value
    }
    publishHandler(){
        pubsub.publish('componentA', this.message)
    }
}


Comp B HTML: Message publish from Comp A displayed here.

<template>
    <lightning-card title="Pubsub demo Component B">
        <div class="slds-p-around_medium">
            Message Recieved - {message}
        </div>
    </lightning-card>
</template>

Comp B JS:  Message publish from Comp A will receive here by the method  call subscribe.

import { LightningElement } from 'lwc';
import pubsub from 'c/pubsub'
export default class PubsubComponentB extends LightningElement {
    message
    connectedCallback(){
        this.callSubscriber()
    }
    callSubscriber(){
        pubsub.subscribe('componentA', (message)=>{
            this.message = message
        })
    }
}

Indivual JS: This JS will have method to publish or subscribe.
/* eslint-disable no-console */
const store = {};
/**
 * subscribers a callback for an event
 * @param {string} eventName - Name of the event to listen for.
 * @param {function} callback - Function to invoke when said event is fired.
 */

const subscribe = (eventName, callback) => {
    if (!store[eventName]) {
        store[eventName] = new Set();
    }
    store[eventName].add(callback);
};

/**
 * unsubscribe a callback for an event
 * @param {string} eventName - Name of the event to unsubscribe from.
 * @param {function} callback - Function to unsubscribe.
 */
const unsubscribe = (eventName, callback) => {
    if (store[eventName]) {
        store[eventName].delete(callback);
    }
};

/**
 * Publish an event to listeners.
 * @param {string} eventName - Name of the event to publish.
 * @param {*} payload - Payload of the event to publish.
 */

const publish = (eventName, payload) => {
    if (store[eventName]) {
        store[eventName].forEach(callback => {
            try {
                callback(payload);
            } catch (error) {
                console.error(error);
            }
        });
    }
};

export default {
    subscribe,
    unsubscribe,
    publish
};




Setter method in Parent child Component

This method is used to modified data coming from Parent comp.  Setter and Getter always use together and method names should be same.  
Whenever object passed as data to setter, to do changes to object we have create shallow copy otherwise it will error.

 
Parent HTML
<template>
    <lightning-card title="Setter Method Demo">
        <c-setter-demo-child detail={userDetails}></c-setter-demo-child>
    </lightning-card>
</template>

Parent JS:  From parent we sendind age is 25 and it’s doubled in Comp b and displayed by using setter.
import { LightningElement } from 'lwc';

export default class SetterDemoParent extends LightningElement {
    userDetails = {
        name:"salesforcetroop",
        age:25
    }
}

Child HTML
<template>
    <p><strong>Name</strong> - {detail.name}</p>
    <p><strong>Age</strong> - {detail.age}</p>
    <p><strong>location</strong> - {detail.location}</p>
</template>

Child JS
import { LightningElement, api } from 'lwc';

export default class SetterDemoChild extends LightningElement {
    userDetail

    @api
    get detail(){
        return  this.userDetail
    }
    set detail(data){
        let newAge = data.age*2
        this.userDetail = {...data, age:newAge, "location":"Melbourne"}
    }
}

Passing markup using slots in Parent child comp
If we want to pass HTML markup from one comp to anther comp  then we will use <Slot>. This used to catch HTML passed by Parent com and we can’t pass Aura component in Slot.
Slots can be created in Child components and data will be come from Parent.

 

Parent HTML:  if create 2 unmaned slots in child and we passing 2 values from Parent then these values displayed in slot1 and slot2 as well(2 vlues displayed)(refer video 66 at 9 min) . To avoid this issue we will use named slots.
<template>
    <lightning-card title="Slot Demos">
        <div class="slds-p-around_medium">
            <c-slot-child-demo>
                <p class="slds-text-color_success" slot="first">My Name is Salesforcetroop</p>
                <p class="slds-text-color_error" slot="second">My Age is 25</p>
                <p slot="footer"> I am footer</p>
            </c-slot-child-demo>
        </div>
        <div class="slds-p-around_medium">
            <c-slot-child-demo>
                <p class="slds-text-color_success" slot="first">My Name is Salesforcetroop</p>
                <p class="slds-text-color_error" slot="second">My Age is 25</p>
                <!-- <p slot="footer"> I am footer</p> -->
            </c-slot-child-demo>
        </div>
    </lightning-card>
</template>


Parent JS:
import { LightningElement } from 'lwc';

export default class SlotParentDemo extends LightningElement {}

Child HTML

<template>
    <div>What is Your Name?</div>
    <div><slot name="first"></slot></div> <!--named slots-->
    <div>What is Your Age?</div>
    <div><slot name="second"></slot></div> 
    <footer class="slds-card__footer slds-hide">
        <slot name="footer" onslotchange={handleFooterChange}></slot>
    </footer>
</template>

Child JS

import { LightningElement } from 'lwc';

export default class SlotChildDemo extends LightningElement {
    handleFooterChange(){
        const footerElem = this.template.querySelector('.slds-card__footer')
        if(footerElem){
            footerElem.classList.remove('slds-hide')
        }
    }
}


CSS behavior in Parent child component
	Parent CSS can’t reach to child component. Suppose we have created CSS file parent and applied some style to H1 tag and child also have H1 tag but parent CSS style will not apply to Child H1 tag.
	From parent component we can apply a styles to Child comp Host element only.
	Whenever we sending HTML markup in Slots then from parent then styles will be applied from parent comp only, even we have styles in child those will not applied.

 
 
   

Parent HTML
<template>
    <lightning-card title="CSS composition">
        <div class="slds-p-around_medium">
            <h1>Hello i am parent component</h1>
            <c-css-child-demo>
                <p>Hello I am slot one</p>
            </c-css-child-demo>
            <c-css-child-demo class="blue">
                <p>Hello I am slot two</p>
            </c-css-child-demo>
        </div>
    </lightning-card>
</template>


Parent JS:
import { LightningElement } from 'lwc';
export default class CssParentDemo extends LightningElement {}

Parent CSS

h1{
    font-size: 30px;
    color:red;
}
/* c-css-child-demo{
    display: block;
    background-color: green;
    color:white;
} */
p{
    font-size: 20px;
    color:yellow;
}

Child HTML
<template>
    <h1>Hello i am child component</h1>
    <slot></slot>
</template>

Child JS
import { LightningElement } from 'lwc';

export default class CssChildDemo extends LightningElement {}


Child CSS

:host{
    display: block;
    background-color: red;
    color:white;
}
:host(.blue){
    display: block;
    background-color: blue;
    color:white;
}


Building Reusable component

Comp A HTML:
<template>
    <!-- <lightning-card variant="narrow" icon-name="standard:opportunity">
        <h1 slot="title">This is a title</h1>
        <h1>This is the body</h1>
        <div slot="actions">
            <lightning-button-icon icon-name="utility:down"></lightning-button-icon>
        </div>
        <div slot="footer">
            <h6>This is the footer</h6>
        </div>
    </lightning-card> -->
    <div class="slds-m-around_medium">
        <c-custom-lightning-card>
            <h1 slot="title">This is a title</h1>
                <h1>This is the body</h1>
            <div slot="actions">
                <lightning-button-icon icon-name="utility:down"></lightning-button-icon>
            </div>
            <div slot="footer">
                <h6>This is the footer</h6>
            </div>
        </c-custom-lightning-card>
    </div>
    <div class="slds-m-around_medium">
        <c-custom-lightning-card>
            <h1 slot="title">This card is without footer</h1>
                <h1>This is the body</h1>
            <div slot="actions">
                <lightning-button-icon icon-name="utility:down"></lightning-button-icon>
            </div>
        </c-custom-lightning-card>
    </div>
    <div class="slds-m-around_medium">
        <c-custom-lightning-card>
            <h1 slot="title">This card is without action</h1>
                <h1>This is the body</h1>
            <div slot="footer">
                <h6>This is the footer</h6>
            </div>
        </c-custom-lightning-card>
    
    </div>
    <div class="slds-m-around_medium">
        <c-custom-lightning-card>
            <h1 slot="title">This card only contain title</h1>
        </c-custom-lightning-card>
    </div>
    


    

   
   </template>


Comp B Html

<template>
    <article class="slds-card">
        <!--header-->
        <div class="slds-card__header slds-grid">
            <header class="slds-media slds-media_center slds-has-flexi-truncate">
                <div class="slds-media__body">
                    <h2 class="slds-card__header-title">
                        <div class="slds-card__header-link slds-truncate">
                            <slot name="title"></slot>
                        </div>
                    </h2>
                </div>
                <div class="slds-no-flex">
                    <slot name="actions"></slot>
                </div>
            </header>
        </div>
        <!--body-->
        <div class="slds-card__body">
           <slot></slot>
        </div>
        <!--footer-->
        <footer class="slds-card__footer slds-hide">
            <slot name="footer" onslotchange={handleSlotFooterChange}></slot>
        </footer>
        
        </article>
</template>

Comp B JS

import { LightningElement } from 'lwc';

export default class CustomLightningCard extends LightningElement {
    handleSlotFooterChange(){
        const footerElem = this.template.querySelector('footer')
        if(footerElem){
            footerElem.classList.remove('slds-hide')
        }
    }
}

Aura Coexistence
Within aura component we can insert as many LWC components but in LWC component we can’t insert Aura component. To add Lwc component in Aura use below syntax in Aura,
<c:LWCcomponent name> </c:LWCcomponent name>

To transfer the data b/w auara component we will use LWC communication methods like @api, events 

 

LWC comp HTML:
<template>
    <div>{title}</div>
    <lightning-button variant="brand" label="Send msg" onclick={callAura}>     
    </lightning-button>
</template>

LWC Comp JS:
import { LightningElement, api } from 'lwc';

export default class LwcAuraCommunication extends LightningElement {
    @api title

    callAura(){
        const event= new CustomEvent('sendmsg', {
                detail:{
                    "msg":"Hello From LWC"
                }
            })
        this.dispatchEvent(event)
    }
}

Aura comp:
<aura:component implements="flexipage:availableForAllPageTypes">
<aura:attribute name="message" type="String"/>
<lightning:card title="Aura to LWC communication">
    <div class="slds-p-around_medium">
        <div>{!v.message}</div>
    </div>
    <div class="slds-p-around_medium">
        <c:lwcAuraCommunication onsendmsg="{!c.handleMsg}" title="Hello this message is from Aura"></c:lwcAuraCommunication>
    </div>
</lightning:card>
</aura:component>	


Aura Comp JS:
({
    handleMsg : function(component, event) {
        var msg = event.getParam('msg')
        component.set("v.message", msg)
    }
})

9)	Lightning Messaging Service 

Lightning messaging service introduced in winter20 release. With help of LMS we can communicate any page in salesforce like VF to aura, vf to LWC, aura to LWC , aura to VF and Vice versa.

This is very important topic in LWC.
 
 
	To use LMS we need create folder messaeChannel under path force-app\main\defaut and in this folder create a file CHANNELNAME.messageChannel-meta.xml.



 



	In the created file we need add data like below. In below masterLabel tag is the name of the message channel.  If we want set message for fields then use lightningMessageFields tag and under this use Fieldname(This field names shoulbe unique we will use this field names to pass the message)  and description tags. See below.

<?xml version="1.0" encoding="UTF-8" ?>
<LightningMessageChannel xmlns="http://soap.sforce.com/2006/04/metadata">
    <masterLabel>SampleMessageChannel</masterLabel>
    <isExposed>true</isExposed>
    <description>Message Channel to pass data</description>
    <lightningMessageFields>
        <fieldName>lmsData</fieldName>
        <description>This is the field to pass data</description>
    </lightningMessageFields>
</LightningMessageChannel>

	Then update manifest/package.xml file adding Lightning message channel as below and updated API version be above 47 & above.

   <types>
        <members>*</members>
        <name>LightningMessageChannel</name>
    </types>


 


LWC to LWC communication using LMS

We will use LMS to communicate two independent LWC components.
	First we need to reference the our message channel file created in message channel folder with below syntax.
Sysntax:

Import message channel name from “@salesforce/messageChannel/channelname__c”
	Imports the API’s required like Publish, subscribe.
	Message context wire adaptor will give the information of All LWC components that are using LMS.
 

	To publish the message using wire adaptor use below syntax. See below diagram.

 

Comp A HTML
<template>
    <lightning-card title="LWC LMS Component A">
        <div class="slds-m-around_medium">
            <lightning-input type="text" label="Enter message to publish" 
            onkeyup={inputHandler}></lightning-input>
        </div>
        <div class="slds-m-around_medium">
            <lightning-button label="Publish" onclick={publishMessage}></lightning-button>
        </div>
    </lightning-card>
</template>

Comp A JS

import { LightningElement, wire } from 'lwc';
import SAMPLEMC from "@salesforce/messageChannel/SampleMessageChannel__c"
import {MessageContext, publish} from 'lightning/messageService'
export default class LmsComponentA extends LightningElement {
    inputValue

    @wire(MessageContext)
    context

    inputHandler(event){
        this.inputValue = event.target.value
    }

    publishMessage(){
        const message={
            lmsData:{
                value:this.inputValue
            }
        }
        //publish(messageContext, messageChannel, message)
        publish(this.context, SAMPLEMC, message)
    }
}

Comp b HTML:

<template>
    <lightning-card title="LWC LMS Component X">
        <div class="slds-m-around_medium">
           <lightning-button label="unsubscribe" onclick={unsubscribeMessage}></lightning-button>
        </div>
        <div class="slds-m-around_medium">
            Message Recieved <strong>{recievedMessage}</strong>
        </div>
    </lightning-card>
</template>

Comp B JS:

import { LightningElement, wire } from 'lwc';
import SAMPLEMC from "@salesforce/messageChannel/SampleMessageChannel__c"
import {subscribe, MessageContext, APPLICATION_SCOPE, unsubscribe} from 'lightning/messageService';
export default class LmsComponentX extends LightningElement {
    recievedMessage
    subscription
    @wire(MessageContext)
    context

    connectedCallback(){
        this.subscribeMessage()
    }

    subscribeMessage(){
        //subscribe(messageContext, messageChannel, listener, subscriberOptions)
        this.subscription= subscribe(this.context, SAMPLEMC, (message)=>{this.handleMessage(message)}, {scope:APPLICATION_SCOPE})
    }

    handleMessage(message){
        this.recievedMessage = message.lmsData.value? message.lmsData.value :'NO Message published'
    }

    unsubscribeMessage(){
        unsubscribe(this.subscription)
        this.subscription = null
    }
    
}


LWC to Aura communication using LMS

To use LMS we need to set up message channel in Aura component like below. 
 

In below example if we enter message from LWC comp A then publish it will be send to LWc compb and Aura component as well. 
If we publish from Aura then LWC Comp will receive message(We have written code in Comp b only)

Aura Comp:

<aura:component implements="flexipage:availableForAllPageTypes" access="global">
<aura:attribute name="messageValue" type="String"/>
<aura:attribute name="messageRecieved" type="String"/>

<lightning:messageChannel
    type="SampleMessageChannel__c"
    aura:id="SampleMessageChannel"
    onMessage="{!c.handleMessage}"
    scope="APPLICATION"
/>
    <lightning:card title="LMS Aura Component">
        <div class="slds-p-around_medium">
            <label>Enter publish message</label>
            <input type="text"
            id="messageInput"
            name="messageInput"
            class="slds-input"
            value="{!v.messageValue}"
            onkeyup="{!c.inputHandler}"/>
        </div>
        <div class="slds-p-around_medium">
            <lightning:button onclick="{!c.publishMessage}">Publish</lightning:button>
        </div>

        <div class="slds-p-around_medium">
            <h1><strong>Message Recieved</strong></h1>
            <lightning:formattedText value="{!v.messageRecieved}"/>
        </div>
    </lightning:card>
</aura:component>	


Aura JS:
({
    handleMessage:function(component, message){
        if(message != null && message.getParam("lmsData") !=null){
            component.set("v.messageRecieved", message.getParam("lmsData").value)
        }
    },
    inputHandler:function(component, event){
        console.log(event.target.value)
        component.set("v.messageValue", event.target.value)
    },
    publishMessage:function(component){
        let msg = component.get("v.messageValue")
        let message={
            lmsData:{
                value:msg
            }
        }
        component.find("SampleMessageChannel").publish(message)
    }
})


Comp A HTML

<template>
    <lightning-card title="LWC LMS Component A">
        <div class="slds-m-around_medium">
            <lightning-input type="text" label="Enter message to publish"
            onkeyup={inputHandler} value={inputValue}></lightning-input>
        </div>
        <div class="slds-m-around_medium">
            <lightning-button label="publish" onclick={publishMessage}></lightning-button>
        </div>
    </lightning-card>
</template>

Comp A JS

import { LightningElement, wire } from 'lwc';
import SAMPLEMC from '@salesforce/messageChannel/SampleMessageChannel__c'
import {MessageContext, publish} from 'lightning/messageService'
export default class ComponentAforLMS extends LightningElement {
    inputValue

    @wire(MessageContext)
    context

    inputHandler(event){
        this.inputValue = event.target.value
    }

    publishMessage(){
        const message={
            lmsData:{
                value:this.inputValue
            }
        }
        publish(this.context, SAMPLEMC, message)
        //this.context is the context of the current lightning web component with LMS
        //SAMPLEMC is the reference of the Message Channel
        //message is the data to publish
    }
}


Comp B HTML

<template>
    <lightning-card title="LWC LMS Component X">
        <div class="slds-m-around_medium">
            <lightning-button label="unsubscribe" onclick={unsubscribeMessage}></lightning-button>
        </div>
        <div class="slds-m-around_medium" slot="footer">
            <p>message recieved :<strong>{recievedMessage}</strong></p>
        </div>
    </lightning-card>
</template>

Comp B JS

import { LightningElement, wire } from 'lwc';
import SAMPLEMC from '@salesforce/messageChannel/SampleMessageChannel__c'
import {APPLICATION_SCOPE, MessageContext, subscribe, unsubscribe} from 'lightning/messageService'
export default class ComponentXforLMS extends LightningElement {
    @wire(MessageContext)
    context
    subscription 
    recievedMessage
    connectedCallback(){
        this.subscribeMessage()
    }
    subscribeMessage(){
        // subscribe(messageContext, messageChannel, listener, subscriberOptions)
       this.subscription= subscribe(this.context, SAMPLEMC, (message)=>{this.handleMessage(message)}, {scope:APPLICATION_SCOPE})
        //this.context is the context of the current lightning web component with LMS
        //SAMPLEMC is the reference of the Message Channel
        //To receive messages on a message channel from anywhere in the application, pass the subscriberOptions parameter as {scope: APPLICATION_SCOPE}
    }
    handleMessage(message){
        //write logic for message
        this.recievedMessage = message && message.lmsData && message.lmsData.value ? message.lmsData.value:'No Message'
    }

    unsubscribeMessage(){
        unsubscribe(this.subscription)
        this.subscription = null
    }
}

LWC, Aura and VF communication using LMS


 

To expose VF page to lightning environment we need to enable available lightning experience check box. 
 

Refer LWC Comp A, B and Aura comp code in above section.
VF Code

<apex:page lightningStylesheets="true">
    <apex:slds/>
    <div class="slds-scope">
        <div class="slds-p-around_small">
            <label>Enter publish Message</label>
            <input type="text" class="slds-input" id="messageField"/>
            <div class="slds-p-top_small slds-p-bottom_small">
                <button class="slds-button slds-button_neutral" onclick="publishHandler()">Publish</button>
                <button class="slds-button slds-button_neutral" onclick="subscriberHandler()">Subscribe</button>
                <button class="slds-button slds-button_neutral" onclick="unsubscriberHandler()">Unsubscribe</button>
            </div>

            <p>message Recieved</p>
            <div id="recievedMessage"></div>
        </div>
    </div>
    <script>
      let SAMPLEMC  ="{!$MessageChannel.SampleMessageChannel__c}"
      let subscriptionToMC
      function publishHandler(){
          let data = document.getElementById("messageField").value
          const message={
              lmsData:{
                  value:data
              }
          }
          sforce.one.publish(SAMPLEMC, message)
      }

      function subscriberHandler(){
          if(!subscriptionToMC){
            subscriptionToMC = sforce.one.subscribe(SAMPLEMC, msgHandler, {scope:"APPLICATION"})
          }
      }

      function unsubscriberHandler(){
          if(subscriptionToMC){
            sforce.one.unsubscribe(subscriptionToMC)
            subscriptionToMC=null
          }
      }

      function msgHandler(message){
          let recievedMessage= document.getElementById("recievedMessage")
          recievedMessage.innerHTML = message && message.lmsData ? message.lmsData.value:"No Data Send"
      }
    </script>
</apex:page>


10)	Resources , Component context and notification 


 





Images from Static resources

We can import static resource from @salesforce/Resourceurl.  Static resource can be archives(such as .zip and .Jar) , images, style sheets java script and other files.

Syntax: import resource name from ‘@salesforce/resourceURL/resource reference’

Resorce name :  name that refer to the static resource in pgm.
Resource refernc: name of the static resource.

	Static resource name can contain only alphanumeric and underscores and must be unique in your ord. Suppose your upload one image with ‘abc’ and you shouldn’t upload other image with same name.
To upload static resource go to setup-> static resource -> upload a new resource.

	It must begin with a letter and not include spaces, not end with underscore and not contain two consecutive underscores.


 

 

HTML code:

<template>
    <lightning-card title="Static Image Demo"> 
        <img src={userImage} alt="User photo" height="100px" width="100px"/>
        <br/>
        <img src={userWalking} alt="Group of people walking"/>
    </lightning-card>
</template>


JS code:

import { LightningElement } from 'lwc';
import USER_IMAGE from '@salesforce/resourceUrl/user_image'
import USER_WALKING_IMG from '@salesforce/resourceUrl/user_walking'
export default class StaticImages extends LightningElement {
    userImage = USER_IMAGE

    userWalking = USER_WALKING_IMG
}

Third party Java Script libraries in LWC 

Upload JS file static resource in SF UI.  In this example we will use Moment.js which is one of the JS zip file that will available in google(see video 76 at 3 min 30 sec) 
loadcript () is the asynchronous process to load the JS file that we have imported. 

 

HTML code:

<template>
    <lightning-card title="Third Party JS Demo">
        <p><strong>Current Date Is -</strong> {currentDate}</p>
    </lightning-card>
</template>



JS code: in Below we using not using promise since we loading single file only. so LoadScript () is the  asynchronous process once file loading operation completed successfully then it will call then() method otherwise error() method will call.

import { LightningElement } from 'lwc';
import MOMENT from '@salesforce/resourceUrl/moment'
import {loadScript} from 'lightning/platformResourceLoader'
export default class ThirdPartyFiles extends LightningElement {
    currentDate=''
    isLibLoaded = false
    renderedCallback(){ 
        if(this.isLibLoaded){ 
            return
        } else { 
   
            loadScript(this, MOMENT+'/moment/moment.min.js')
.then(()=>{ 
                this.setDateOnScreen()
            }).catch(error=>{ 
                console.error(error)
            })
            this.isLibLoaded = true
        }
       
    }
    setDateOnScreen(){ 
        this.currentDate = moment().format('LLLL')
    }
}

Third party CSS libraries in LWC 

Upload CSS file static resource in SF UI. 
loadStyle () is the asynchronous process to load the CSS file that we have imported. 


 

HTML code:

<template>
    <lightning-card title="Third Party JS Demo">
        <p><strong>Current Date Is -</strong> {currentDate}</p>
    </lightning-card>

    <lightning-card title="Third Party CSS Demo">
        <p class="animate__animated animate__bounce animate__delay-5s">Hurray!! i am enjoying this session!</p>
    </lightning-card>
</template>


JS code: in Below we using promise since we are using the loadStyle() and loadScript() so both are asynchronous process so we using Promise.all() once both files loading operation completed successfully then it will call then() method otherwise error() method will call.

import { LightningElement } from 'lwc';
import MOMENT from '@salesforce/resourceUrl/moment'
import ANIMATE from '@salesforce/resourceUrl/animate'
import {loadScript, loadStyle} from 'lightning/platformResourceLoader'
export default class ThirdPartyFiles extends LightningElement {
    currentDate=''
    isLibLoaded = false
    renderedCallback(){ 
        if(this.isLibLoaded){ 
            return
        } else { 
            
            Promise.all([
                loadStyle(this, ANIMATE+'/animate/animate.min.css'), 
                loadScript(this, MOMENT+'/moment/moment.min.js')
            ]).then(()=>{ 
                this.setDateOnScreen()
            })
            this.isLibLoaded = true
            
        }
       
    }
    setDateOnScreen(){ 
        this.currentDate = moment().format('LLLL')
    }
}


Content asset files

In salesforce Go to files and libraries there you can find assert library. Here we can upload assert files.
Import Content assert file from @salesforce/contentAssertUrl.  Convert salesforce file into continent assert file to use file in Custom app and Community templates.
 
Import content assert name from ‘@salesforce/contentAssertUrl/Contetnt assert Reference’


 

HTML code:

<template>
    <lightning-card title="Content Asset Demo">
        <a href={file} download>Download</a>
    </lightning-card>
</template>

JS code:

import { LightningElement } from 'lwc';
import TYPESCRIPT_FILE from '@salesforce/contentAssetUrl/typescripthandbookbetapdf'
export default class ContentAssetFiles extends LightningElement {
    file = TYPESCRIPT_FILE
}
Internationalization 

Based on the your org set details will be imported from current org and displayed.
Import internationalization property name from @saleforce/i18n/internationalization property.

 

Properties :
 



HTML code:

<template>
    <lightning-card title="Internationalization Demo"> 
        <p dir={dir}>{formattedNumber}</p>
    </lightning-card>
</template>

JS code:
import { LightningElement } from 'lwc';
import LOCALE from '@salesforce/i18n/locale'
import CURRENCY from '@salesforce/i18n/currency'
import DIR from '@salesforce/i18n/dir'
export default class Internationalization extends LightningElement {
    dir = DIR //'rtl'
    number = 6575557.86
    formattedNumber = new Intl.NumberFormat(LOCALE, { //'ar-EG'
        style:'currency',
        currency:CURRENCY, //'usd'
        currencyDisplay:'symbol'
    }).format(this.number)
}



Access lables

Import labels from @salesforce/label.  Custom lables are text values in SF that can be translated into any language that SF supports. Use custom labels to create multi language applicaton that present information in a user native language. 

Syntax:
Import lablename from ‘@salesforce/label/lablereference’.

Note: the name of label in your org in the format i.e namespace.labelname.

Setup-> custom labels-> create a new.

 

HTML code:

<template>
    <lightning-card title="Custom Label Demo"> 
        <p>{LABELS.descriptionOne}</p>
        <p>{LABELS.descriptionTwo}</p>
    </lightning-card>
</template>


JS code:

import { LightningElement } from 'lwc';
import DESCRIPTION_ONE from '@salesforce/label/c.descriptionOne'
import DESCRIPTION_TWO from '@salesforce/label/c.descriptionTwo'
export default class CustomLabelsDemo extends LightningElement {
    LABELS = { 
        descriptionOne:DESCRIPTION_ONE,
        descriptionTwo:DESCRIPTION_TWO
    }
}


Check Permissions

In LWC component itself we can check the two type of permissions without writing Apex code and this one is introduced in Summer20 and this will return Boolean value. 
1)	User permission 
In profile we have ‘General User permission section’ we will import values from this section by using this import. 

Import has permission from  ‘@salesforce/userPermission/Permission name’

2)	Custom permission: we can create a custom permission with-> set up-> quick find then search custom permission. Then we can include this custom permission in the permission set.

Import hasPermission from ‘@salesforce/customPermission/Permission name’
 

HTML code:
<template>
    <lightning-card title="USER Permission Demo"> 
        <template if:true={hasViewAllDataAvialable}>
            <p>Hurray!! I have a user permission</p>
        </template>
        <template if:false={hasViewAllDataAvialable}>
            <p>Opps!! I don't have a user permission</p>
        </template>
    </lightning-card>

    <lightning-card title="Custom Permission Demo"> 
        <template if:true={hasCustomPermission}>
            <p>Hurray!! I have a Custom permission</p>
        </template>
        <template if:false={hasCustomPermission}>
            <p>Opps!! I don't have a Custom permission</p>
        </template>
    </lightning-card>
</template>

JS code:

import { LightningElement } from 'lwc';
import hasViewAllData from '@salesforce/userPermission/ViewAllData'
import myCustomPermission from '@salesforce/customPermission/show_details'
export default class CheckPermissionDemo extends LightningElement {

    get hasViewAllDataAvialable(){ 
        return hasViewAllData
    }

    get hasCustomPermission(){ 
        return myCustomPermission
    }
}
Access client form factor

Form factor will give the where browser is running on like desk top or mobile. The possible values are 
Large— desktop
Medium—tablet 
Small- Phone.

Syntax:; 
Import form factor name  from ‘@salesforce/client/formfactor’


 

HTML code:
<template>
    <lightning-card title="Form Factor Demo">
        <p>Form factor is {formFactor}</p>
    </lightning-card>
</template>

JS code:

import { LightningElement } from 'lwc';
import FORM_FACTOR from '@salesforce/client/formFactor'
export default class FormFactorDemo extends LightningElement {
    formFactor = FORM_FACTOR
}

Get current user information

This will help to get the User properties. It will support only id (User id) and isGuest(Boolean).

Import property from ‘@salesforce/user/property’


 

HTML code:
<template>
    <lightning-card title="Get User InFo Demo">
        <p><strong>User Id Is - </strong>{userId}</p>
        <p><strong>Is User Guest - </strong>{isGuest}</p>
    </lightning-card>
</template>

JS code:

import { LightningElement } from 'lwc';
import ID from '@salesforce/user/Id'
import IS_GUEST from '@salesforce/user/isGuest'
export default class UserInformation extends LightningElement {
    userId = ID
    isGuest = IS_GUEST
}

Fetch Record ID and Object name

If the LWC component is placed in record page then @api recordId will get the current record id and  @api objectApiName will get the current object name.

If the component placed in App page or Home page then these values will be null.


 

HTML code:

<template>
   <lightning-card title="RecordId and Object Name Demo"> 
       <p> Record Id is {recordId}</p>
       <p> Object Name is {objectApiName}</p>
   </lightning-card> 
</template>

JS code:

import { LightningElement, api } from 'lwc';

export default class RecordIdAndObjectName extends LightningElement {
    @api recordId
    @api objectApiName
}

Toast Notification

Toast is the popup that alert user with some information. Toast can be of success , error, info or warning. We can send toast notification by using ShowToastEvent method,  this is the custom event we can create with this method and dispatch it.

Import {ShowToastEvent} from ‘lightning/platformshowToastEvent’
For this method we have a following parametrs,
o	Title-> title of the toast notification 
o	Message->  message of the toast
o	Variant-> toast variant i.e success, error, info or warning
o	Message data-> if we want pass the URL that can clickable we will use this parameter.
o	Mode: Mode of the toast. Valid values are 
1)	Dismissable (default) : Remains visible until user click close button or 3 seconds has elapsed, which before 3 seconds if user click close button it will close other wise after 3 seconds it will close autmatically.
2)	Pester: visible for 3 seconds
3)	Sticky: remains visible until user the user clicks close. 
Const evt = new ShowToastEvent({
Title : “Toast title”,
Message: “toast message”,
Variant: “toast variant”
})


 

HTML code:

<template>
    <lightning-card title="Notifications Demo">
        <lightning-button variant="brand" label="Success" onclick={toastHandler}></lightning-button>
        <lightning-button variant="brand" label="Error" onclick={toastHandlerTwo}></lightning-button>
        <lightning-button variant="brand" label="Warning" onclick={toastHandlerThree}></lightning-button>
        <lightning-button variant="brand" label="Info" onclick={toastHandlerFour}></lightning-button>
    </lightning-card>
</template>

JS code:

import { LightningElement } from 'lwc';
import {ShowToastEvent} from 'lightning/platformShowToastEvent'
export default class Notifications extends LightningElement {

    toastHandler(){ 
        this.showToast("Success!!", "{0} Account Created!! {1}", "success")
    }
    toastHandlerTwo(){ 
        this.showToast("Error!!", "Account Creation Failed!!", "error")
    }
    toastHandlerThree(){ 
        this.showToast("Warning!!", "Password should have 15 characters!!", "warning")
    }	
    toastHandlerFour(){ 
        this.showToast("Info!!", "Summer 20 realease is available!!", "info")
    }
//the best way to create single toast method and handle all possible ways instead of creation methos for every button or action see below  snap shot.
    showToast(title, message, variant){ 
        const event = new ShowToastEvent({ 
            title,
            message,
            variant,
            messageData:[
                'Salesforce',{ 
                    url:'http://www.salesforce.com/',
                    label:'Click Here'
                }
            ],
            mode:'sticky'
        })
        this.dispatchEvent(event)
    }
}

Here we are creating event for every method instead of this, create event in one method and pass the required parameters as per the above example.

 

11)	Memory game Project 

HTML code:

<template>
    <div class="container">
        <lightning-card title="Memory Game">
            <div class="slds-var-p-around_medium">
                <section class="score-panel">
                    <span class="moves">{moves}</span> Move(s)
                    <div class="timer">{totalTime}</div>
                    <div class="restart" onclick={shuffle}>
                        <i class="fa fa-repeat" aria-hidden="true"></i>
                    </div>
                </section>
                <section class="game-panel">
                   <ul class="deck card-deck grid-container">
                       <template for:each={cards} for:item="card">
                           <li class={card.listClass} type={card.type} key={card.id} onclick={displayCard}>
                               <i class={card.icon}></i>
                           </li>
                       </template>
                   </ul>
                   <template if:true={showCongratulations}>
                    <section role="dialog" tabindex="-1" aria-labelledby="modal-heading-01" aria-modal="true" aria-describedby="modal-content-id-1" class="slds-modal slds-fade-in-open">
                        <div class="slds-modal__container">
                        <header class="slds-modal__header">
                            <h2 id="modal-heading-01" class="slds-modal__title slds-hyphenate">Congratulations you're a winner 🎉 🎉
                            </h2>
                        </header>
                        <div class="slds-modal__content slds-p-around_medium" id="modal-content-id-1">
                            <p>You made <strong>{moves}</strong> moves in {totalTime}</p>
                            <p>Your rating:
                                <template for:each={gameRating} for:item="rating">
                                    <i class="fa fa-star" key={rating}></i>
                                </template>
                            </p>
                        </div>
                        <footer class="slds-modal__footer">
                        <button class="slds-button slds-button_brand" onclick={shuffle}>Play Again</button>
                        </footer>
                        </div>
                        </section>
                        <div class="slds-backdrop slds-backdrop_open"></div>
                   </template>
                   
                </section>
            </div>
        </lightning-card>
    </div>
</template>


JS code

import { LightningElement } from 'lwc';
import {loadStyle} from 'lightning/platformResourceLoader'
import fontawesome from '@salesforce/resourceUrl/fontawesome'
export default class MemoryGameLwc extends LightningElement {

    isLibLoaded = false
    openedCards =[]
    matchedCard=[]
    totalTime='00:00'
    moves=0
    timerRef
    showCongratulations = false
    cards= [
        {id:1, listClass:"card", type:'diamond', icon:'fa fa-diamond'},
        {id:2, listClass:"card", type:'plane', icon:'fa fa-paper-plane-o'},
        {id:3, listClass:"card", type:'anchor', icon:'fa fa-anchor'},
        {id:4, listClass:"card", type:'bolt', icon:'fa fa-bolt'},
        {id:5, listClass:"card", type:'cube', icon:'fa fa-cube'},
        {id:6, listClass:"card", type:'anchor', icon:'fa fa-anchor'},
        {id:7, listClass:"card", type:'leaf', icon:'fa fa-leaf'},
        {id:8, listClass:"card", type:'bicycle', icon:'fa fa-bicycle'},
        {id:9, listClass:"card", type:'diamond', icon:'fa fa-diamond'},
        {id:10, listClass:"card", type:'bomb', icon:'fa fa-bomb'},
        {id:11, listClass:"card", type:'leaf', icon:'fa fa-leaf'},
        {id:12, listClass:"card", type:'bomb', icon:'fa fa-bomb'},
        {id:13, listClass:"card", type:'bolt', icon:'fa fa-bolt'},
        {id:14, listClass:"card", type:'bicycle', icon:'fa fa-bicycle'},
        {id:15, listClass:"card", type:'plane', icon:'fa fa-paper-plane-o'},
        {id:16, listClass:"card", type:'cube', icon:'fa fa-cube'},
      ]

      get gameRating(){
          let stars =  this.moves<12 ? [1,2,3]:this.moves>=13 ? [1,2]:[1]
        return this.matchedCard.length ===16 ? stars :[]
        }
      displayCard(event){
          let currCard = event.target
          currCard.classList.add("open", "show", "disabled")
          this.openedCards = this.openedCards.concat(event.target)
          const len = this.openedCards.length
          if(len === 2){
            this.moves = this.moves+1
            if(this.moves === 1){
                this.timer()
            }
            if(this.openedCards[0].type === this.openedCards[1].type){
                this.matchedCard = this.matchedCard.concat(this.openedCards[0], this.openedCards[1])
                this.matched()
            } else {
                this.unmatched()
            }
          }
      }

      matched(){
          this.openedCards[0].classList.add("match", "disabled")
          this.openedCards[1].classList.add("match", "disabled")
          this.openedCards[0].classList.remove("show", "open")
          this.openedCards[1].classList.remove("show", "open")
          this.openedCards=[]
          if(this.matchedCard.length === 16){
              window.clearInterval(this.timerRef)
              this.showCongratulations = true
          }
      }
      unmatched(){
        this.openedCards[0].classList.add("unmatched")
        this.openedCards[1].classList.add("unmatched")
        this.action('DISABLE')
        setTimeout(()=>{
            this.openedCards[0].classList.remove("show", "open", "unmatched")
            this.openedCards[1].classList.remove("show", "open", "unmatched")
            this.action('ENABLE')
            this.openedCards=[]
        },1100)
      }

      action(action){
          let cards = this.template.querySelectorAll('.card')
          Array.from(cards).forEach(item=>{
              if(action === 'ENABLE'){
                  let isMatch = item.classList.contains('match')
                  if(!isMatch){
                      item.classList.remove('disabled')
                  }
              }
              if(action === 'DISABLE'){
                  item.classList.add('disabled')
              }
          })
      }

      timer(){
          let startTime = new Date()
          this.timerRef = setInterval(()=>{
            let diff = new Date().getTime() - startTime.getTime()
            let d = Math.floor(diff/1000)
            const m = Math.floor(d % 3600 / 60);
            const s = Math.floor(d % 3600 % 60);
            const mDisplay = m>0 ? m+(m===1? "minute, ":" minutes, "):""
            const sDisplay = s>0 ? s+(s===1? "second":" seconds"):""
            this.totalTime = mDisplay + sDisplay
          }, 1000)
      }

      shuffle(){
        this.showCongratulations = false
        this.openedCards =[]
        this.matchedCard=[]
        this.totalTime='00:00'
        this.moves=0
        window.clearInterval(this.timerRef)
        let elem = this.template.querySelectorAll('.card')
        Array.from(elem).forEach(item=>{
            item.classList.remove("show", "open", "match", "disabled")
        })
        /***shuffling and swaping logic */
        let array = [...this.cards]
        let counter = array.length
        while(counter>0){
            let index = Math.floor(Math.random()*counter)
            counter--

            let temp = array[counter]
            array[counter] = array[index]
            array[index] = temp
        }
        this.cards = [...array]
      }
    renderedCallback(){
        if(this.isLibLoaded){
            return
        } else {
            loadStyle(this,fontawesome+'/fontawesome/css/font-awesome.min.css').then(()=>{
                console.log("loaded successfully")
            }).catch(error=>{
                console.error(error)
            })
            this.isLibLoaded = true
        }
    }
}


CSS


.container{
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
}
.score-panel{
    text-align: left;
    margin-bottom: 12px;
}
.timer{
    display: inline-block;
    margin: 0 1rem;
}
.restart{
    float: right;
    cursor: pointer;
    margin: 0px 8px;
}
.grid-container{
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
    grid-column-gap: 8px;
    grid-row-gap: 8px;
    background: #1c3260;
    padding: 1rem;
    border-radius: 4px;
    box-shadow: 8px 9px 26px 0 rgba(46, 61, 73, 0.5);
}
.grid-container .card{
    height: 3.7rem;
	width: 3.7rem;
	margin: 0.2rem 0.2rem;
	background: #f03d5f;;
	font-size: 0;
	color: #ffffff;
	border-radius: 5px;
	cursor: pointer;
	display: flex;
	justify-content: center;
	align-items: center;
	box-shadow: 5px 2px 20px 0 rgba(46, 61, 73, 0.5);
}
.grid-container .card.open{
    transform: rotateY(0);
    background: #02b3e4;
	cursor: default;
	animation-name: flipInY;
	-webkit-backface-visibility: visible !important;
	backface-visibility: visible !important;
	animation-duration: .75s;
}
.grid-container .card.show{
    font-size: 33px;
    visibility: visible !important;
	opacity: 100 !important;
}
.grid-container .card.disabled{
    pointer-events: none;
    opacity: 0.9;
}

.grid-container .card.match{
    cursor: default;
	background: #E5F720;
	font-size: 33px;
	animation-name: rubberBand;
	-webkit-backface-visibility: visible !important;
	backface-visibility: visible !important;
	animation-duration: .75s;
}
.grid-container .card.unmatched{
    animation-name: pulse;
	-webkit-backface-visibility: visible !important;
	backface-visibility: visible !important;
	animation-duration: .75s;
	background: #e2043b;
}
/*animations*/
@keyframes flipInY {
	from {
		transform: perspective(400px) rotate3d(0, 1, 0, 90deg);
		animation-timing-function: ease-in;
		opacity: 0;
	}

	40% {
		transform: perspective(400px) rotate3d(0, 1, 0, -20deg);
		animation-timing-function: ease-in;
	}

	60% {
		transform: perspective(400px) rotate3d(0, 1, 0, 10deg);
		opacity: 1;
	}

	80% {
		transform: perspective(400px) rotate3d(0, 1, 0, -5deg);
	}

	to {
		transform: perspective(400px);
	}
}
@keyframes rubberBand {
	from {
		transform: scale3d(1, 1, 1);
	}

	30% {
		transform: scale3d(1.25, 0.75, 1);
	}

	40% {
		transform: scale3d(0.75, 1.25, 1);
	}

	50% {
		transform: scale3d(1.15, 0.85, 1);
	}

	65% {
		transform: scale3d(.95, 1.05, 1);
	}

	75% {
		transform: scale3d(1.05, .95, 1);
	}

	to {
		transform: scale3d(1, 1, 1);
	}
}
@keyframes pulse {
	from {
		transform: scale3d(1, 1, 1);
	}

	50% {
		transform: scale3d(1.2, 1.2, 1.2);
	}

	to {
		transform: scale3d(1, 1, 1);
	}
}

   
12)	Navigation Service 

	Home and chatter comes under the Standard__name pages.
	New record, new record with default values, List view and file come under the Standard__objectpage.


 

To implement Navigation service we need to import NavigationMixin function in the JS file and apply the NavigationMixin function to your component base class.

Syntax to import:

Import { NavigationMixin } from ‘lightning/navigation’

To apply navigation function to base class we need to extend the NavigationMixin

Export default class componentname  extends NavigationMixin(lightning element ){}

To dispatch the navigation request, call the navigation service’s like below.

[NavigationMixin.navigate](pagerefernce, [replace])

Page reference: it is the object that defines the page.
Replace: it is the Boolean value which is false by default. If this value is true it page reference replace existing entry In the browser.

 


Below are the page reference that supports.

 


Navigate to Home

Home and chatter comes under the Standard__name pages.
HTML code:

<template>
    <lightning-card title="Navigate To Home">
        <lightning-button variant="brand" label="Navigate To Home"
        onclick={navigateToHome}></lightning-button>
    </lightning-card>

    <lightning-card title="Navigate To Chatter">
        <lightning-button variant="brand" label="Navigate To Chatter"
        onclick={navigateToChatterPage}></lightning-button>
    </lightning-card>
</template>

JS : 

import { LightningElement } from 'lwc';
import {NavigationMixin} from 'lightning/navigation'
export default class NavigateToHome extends NavigationMixin(LightningElement) {

    navigateToHome(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__namedPage',
            attributes:{ 
                pageName:'home'
            }
        })
    }
    navigateToChatterPage(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__namedPage',
            attributes:{ 
                pageName:'chatter'
            }
        })
    }
}


Navigate to Chatter

HTML code:

<template>
    <lightning-card title="Navigate To Home">
        <lightning-button variant="brand" label="Navigate To Home"
        onclick={navigateToHome}></lightning-button>
    </lightning-card>

    <lightning-card title="Navigate To Chatter">
        <lightning-button variant="brand" label="Navigate To Chatter"
        onclick={navigateToChatterPage}></lightning-button>
    </lightning-card>
</template>

JS : 

import { LightningElement } from 'lwc';
import {NavigationMixin} from 'lightning/navigation'
export default class NavigateToHome extends NavigationMixin(LightningElement) {

    navigateToHome(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__namedPage',
            attributes:{ 
                pageName:'home'
            }
        })
    }
    navigateToChatterPage(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__namedPage',
            attributes:{ 
                pageName:'chatter'
            }
        })
    }
}
Navigate to New record
New record, new record with default values, List view and file come under the Standard__objectpage.

HTML
<template>
    <lightning-card title="Navigate to New Record">
        <lightning-button variant="brand" label="New Record"
        onclick={navigateToNewRecord}></lightning-button>

    </lightning-card>
</template>

JS
import { LightningElement } from 'lwc';
import { NavigationMixin } from 'lightning/navigation'
import {encodeDefaultFieldValues} from 'lightning/pageReferenceUtils'
export default class NavigateToObjectPage extends NavigationMixin(LightningElement) {
    navigateToNewRecord(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__objectPage',
            attributes:{ 
                objectApiName:'Contact',
                actionName:'new'
            }
        })
    }
}

Navigate to New record with default values


HTML
<template>
    <lightning-card title="Navigate to New Record">
        <lightning-button variant="brand" label="New Record"
        onclick={navigateToNewRecord}></lightning-button>

    </lightning-card>

    <lightning-card title="Navigate to New Record with default values">
        <lightning-button variant="brand" label="New Record with default values"
        onclick={navigateToNewRecordWithDefault}></lightning-button>

    </lightning-card>
</template>

JS

import { LightningElement } from 'lwc';
import { NavigationMixin } from 'lightning/navigation'
import {encodeDefaultFieldValues} from 'lightning/pageReferenceUtils'
export default class NavigateToObjectPage extends NavigationMixin(LightningElement) {
    navigateToNewRecord(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__objectPage',
            attributes:{ 
                objectApiName:'Contact',
                actionName:'new'
            }
        })
    }

    navigateToNewRecordWithDefault(){
        const defaultValue = encodeDefaultFieldValues({ 
            FirstName:'Zero',
            LastName:'Hero',
            LeadSource:'Other'
        }) 
        this[NavigationMixin.Navigate]({ 
            type:'standard__objectPage',
            attributes:{ 
                objectApiName:'Contact',
                actionName:'new'
            },
            state:{ 
                defaultFieldValues: defaultValue
            }
        })
    }	
}


Navigate to List view 

See code in below files sectionexample.
HTML

JS


Navigate to files


HTML

<template>
    <lightning-card title="Navigate to New Record">
        <lightning-button variant="brand" label="New Record"
        onclick={navigateToNewRecord}></lightning-button>

    </lightning-card>

    <lightning-card title="Navigate to New Record with default values">
        <lightning-button variant="brand" label="New Record with default values"
        onclick={navigateToNewRecordWithDefault}></lightning-button>

    </lightning-card>

    <lightning-card title="Navigate to list view">
        <lightning-button variant="brand" label="Navigate to list view"
        onclick={navigateToListView}></lightning-button>

    </lightning-card>

    <lightning-card title="Navigate to Files">
        <lightning-button variant="brand" label="Navigate to Files"
        onclick={navigateToFiles}></lightning-button>
    </lightning-card>
</template>

JS

import { LightningElement } from 'lwc';
import { NavigationMixin } from 'lightning/navigation'
import {encodeDefaultFieldValues} from 'lightning/pageReferenceUtils'
export default class NavigateToObjectPage extends NavigationMixin(LightningElement) {
    navigateToNewRecord(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__objectPage',
            attributes:{ 
                objectApiName:'Contact',
                actionName:'new'
            }
        })
    }

    navigateToNewRecordWithDefault(){
        const defaultValue = encodeDefaultFieldValues({ 
            FirstName:'Zero',
            LastName:'Hero',
            LeadSource:'Other'
        }) 
        this[NavigationMixin.Navigate]({ 
            type:'standard__objectPage',
            attributes:{ 
                objectApiName:'Contact',
                actionName:'new'
            },
            state:{ 
                defaultFieldValues: defaultValue
            }
        })
    }

    navigateToListView() { 
        this[NavigationMixin.Navigate]({ 
            type:'standard__objectPage',
            attributes:{ 
                objectApiName:'Contact',
                actionName:'list'
            },
            state:{ 
                filterName:'Recent'
            }
        })
    }

    navigateToFiles(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__objectPage',
            attributes:{ 
                objectApiName:'ContentDocument',
                actionName:'home'
            }
        })
    }
}

Navigate to record page in View & Edit Mode
This comes under the Standard__recordpage.

HTML

<template>
    <lightning-card title="Navigate to Record Page in View Mode"> 
        <lightning-button variant="brand" label="View mode"
         onclick={recordViewMode}></lightning-button>

         <lightning-button variant="brand" label="Edit mode"
         onclick={recordEditMode}></lightning-button>
    </lightning-card>
</template>

JS: Demo purpose we are hard coding Record id and object name but in real time we fetch these values by using @api recordId and @api ObjectApiName.

import { LightningElement } from 'lwc';
import { NavigationMixin } from 'lightning/navigation'
export default class NavigateToRecordPage extends NavigationMixin(LightningElement) {

    recordViewMode(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__recordPage',
            attributes:{ 
                recordId:'003N000001laB1ZIAU',
                objectApiName:'Contact',
                actionName:'view'
            }
        })
    }
    recordEditMode(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__recordPage',
            attributes:{ 
                recordId:'003N000001laB1ZIAU',
                objectApiName:'Contact',
                actionName:'edit'
            }
        })
    }
}

Navigate to Tab

This comes under the standard__navItemPage

HTML

<template>
    <lightning-card title="Navigate to Tab">
        <lightning-button variant="brand" label="Navigate to tab"
        onclick={navigateToTab}></lightning-button>
    </lightning-card>
</template>

JS
import { LightningElement } from 'lwc';
import {NavigationMixin} from 'lightning/navigation'
export default class NavigateToNavItemPage extends NavigationMixin(LightningElement) {
    navigateToTab(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__navItemPage',
            attributes:{ 
                apiName:'Styling_in_LWC'
            }
        })
    }
}


Navigate to record relationship page 
This comes under the standard__recordRelationshipPage.
HTML
<template>
    <lightning-card title="Navigate to related contacts of account">
        <lightning-button variant="brand" label="Navigate"
        onclick={navigateToRelatedList}>
        </lightning-button>
    </lightning-card>
</template>

JS

import { LightningElement } from 'lwc';
import { NavigationMixin } from 'lightning/navigation'
export default class NavigateToRelatedRelationship extends NavigationMixin(LightningElement) {
    navigateToRelatedList(){ 
        this[NavigationMixin.Navigate]({ 
            type:'standard__recordRelationshipPage',
            attributes:{ 
                recordId:'001N000001ytCVOIA2',
                objectApiName:'Account',
                relationshipApiName:'Contacts',
                actionName:'view'
            }
        })
    }
}

Navigate to external web page

This comes under standard__webpage.

HTML

<template>
    <lightning-card title="Navigate to Web Page">
        <lightning-button variant="brand" label="Navigate to web page"
        onclick={navigateToWeb}></lightning-button>
    </lightning-card> 
</template>

JS

import { LightningElement } from 'lwc';
import { NavigationMixin } from 'lightning/navigation'
export default class NavigateToWebPage extends NavigationMixin(LightningElement) {
    navigateToWeb(){ 
        this[NavigationMixin.Navigate]({ 
            type:"standard__webPage",
            attributes:{ 
                url:"https://www.salesforcetroop.com"
            }
        })
    }
}

Navigate to LWC page

This comes under the standard__webPage.
Comp A  HTML

<template>
    <lightning-card title="navigate to lwc">
        <lightning-button variant="brand" 
        label="navigate to lwc" onclick={navigateToLwc}></lightning-button>
    </lightning-card>
</template>

Comp A JS: to navigate other LWC page we need to define a definition of the target LWC page as below there we will provide to which component we need to navigate and data need to be pass in attributes. Then convert that definition in to string and it will navigate to target comp.

import { LightningElement } from 'lwc';
import { NavigationMixin } from 'lightning/navigation'
export default class NavigateToLwc extends NavigationMixin(LightningElement) {
    navigateToLwc(){ 
        var defination={ 
            componentDef:'c:navigationLwcTarget',
            attributes: { 
                recordId:'768766686686'
            }
        }
        this[NavigationMixin.Navigate]({ 
            type:'standard__webPage',
            attributes: { 
                url:'/one/one.app#'+btoa(JSON.stringify(defination))
            }
        })
    }
    
}

Comp B HTML

<template>
    <lightning-card title="navigate to Target">
        <p>Welcome to the Navigate lwc targetwith recordid {recordId}</p>
    </lightning-card>
</template>

Comp B JS

import { LightningElement, api } from 'lwc';

export default class NavigationLwcTarget extends LightningElement {
    @api recordId
}

Navigate to Aura component

This comes under the standard__component.

LWC HTML

<template>
    <lightning-card title="navigate to AURA">
        <lightning-button variant="brand" 
        label="navigate to AURA"
        onclick={navigateToAura}></lightning-button>
    </lightning-card>
</template>

LWC JS

import { LightningElement } from 'lwc';
import { NavigationMixin } from 'lightning/navigation'
export default class NavigateToAuraComponent extends NavigationMixin(LightningElement) {
    navigateToAura(){ 
        this[NavigationMixin.Navigate]({ 
            type:"standard__component",
            attributes:{ 
                componentName:"c__AuraNavigation"
            },
            state:{ 
                "c__id":"7876868687686"
            }
        })
    }
}


Aura Comp

<aura:component implements="flexipage:availableForAllPageTypes, 
lightning:isUrlAddressable" access="global">
    <aura:attribute name="id" type="String"/>
    <aura:handler name="init" value="{!this}" action="{!c.onload}"/>

    <div class="slds-card">
        <div> Hey I am coming from lwc and my record id is {!v.id}</div>
    </div>
</aura:component>	

Aura JS


({
    onload : function(component) {
        var myPageRef = component.get("v.pageReference")
        var id = myPageRef.state.c__id
        component.set("v.id", id)
    }
})
 
Navigate to VF page

This comes under the standard__webPage.
HTML

<template>
    <lightning-card title="navigate to VF page">
        <lightning-button variant="brand" 
        label="navigate to VF page" onclick={navigateToVFPage}></lightning-button>
    </lightning-card>
</template>

JS: Create on VF page and make available for lightning use and provide that VF name in URL section like /apex/vf name. So basically navigating to VF will give you the promise method so we need to use  .then method. 

import { LightningElement } from 'lwc';
import { NavigationMixin } from 'lightning/navigation'
export default class NavigateToVfpage extends NavigationMixin(LightningElement) {
    navigateToVFPage(){ 
        this[NavigationMixin.Navigate]({ 
            type:"standard__webPage",
            attributes:{ 
                url:"/apex/navigateVfpage"
            }
        }).then(generatedUrl=>{ 
            console.log(generatedUrl)
            window.open(generatedUrl)
        })
    }
}


Fetch current page reference 
To get the page reference we need to import CurrentPageReference which is from the Wire service.

import {CurrentPageReference} from 'lightning/navigation'

HTML

<template>
    <lightning-card title="Current Page reference">
        <p>{pageReference}</p>
    </lightning-card>
</template>

JS

import { LightningElement, wire } from 'lwc';
import {CurrentPageReference} from 'lightning/navigation'
export default class CurrentReference extends LightningElement {
    @wire(CurrentPageReference)
    pageRef

    get pageReference(){ 
        return this.pageRef ? JSON.stringify(this.pageRef, null, 2) : '';
    }
}

13)	Work with SF Data in LWC
There are many ways of interacting with salesforce data in the LWC. Knowing which approach to use for a Particular use case helps you to write less code, easier code and code that is more maintainable.  Below the methods.
1)	Base lightning components built on Lightning data service -> easier to implement but less flexibility.
2)	Lightning data service wire adaptor and functions-> easier to use and more flexible than base components.
3)	Apex-> Extremely flexible. 
 


Lightning Data Service:

 

	First if we try to fetch A record it will check in LDS cache if not found goto server fetch data and store it in LDS cache then return record to browser.
	If we try fetch record A again it will check in cache found record so return record  to browser from LDS cache.

Adavantages:

LDS cache will save the server calls.



 

Use Cases for Interacting with Salesforce Data
Use Case	Recommended Solution	Notes
View or edit a record specifying its layout or a list of fields	lightning-record-form	
View a record with a custom form layout or custom rendering of record data	lightning-record-view-form	
Edit a record with a custom form layout, custom rendering of record data, or prepopulated field values	lightning-record-edit-form	
Read metadata or read data for one record	LDS wire adapters	Can be combined, but operations will run on independent transactions
Create, edit, or delete one record	LDS functions	Can be combined, but operations will run on independent transactions
Read multiple records	Call Apex with @wire	Annotate the Apex method with cacheable=true
Read multiple records on a one-time invocation or modify multiple records	Call Apex imperatively	For reads, annotate the Apex method with cacheable=true
When you work with data in Lightning web components, error handling varies. How you access errors depends on how you’re interacting with the data.

Link to use reduce error method to show handle errors.

https://github.com/trailheadapps/lwc-recipes/blob/main/force-app/main/default/lwc/ldsUtils/ldsUtils.js

Base lightning components built on Lightning data service
Base lightning components are built on lightning data service. So light data service is used behind the scenes by By base components and inherits its caching and synchronization capabilities.
There are 3 types of base lightning components built on LDS are 
1)	Lightning-record-form
2)	Lightning-record-edit-form
3)	Lightning-record-view-form
When to use these forms:
	Create a metadata driven UI or form based UI similar to the record details page in SF.
	Display record values based on the field metadata.
	Hide or show localized field labels
	Display the help text on custom field
	Perform client-side validation and enforce validation rules.

 

 


Lightning-record-form

	Use lightning-record-form component to quickly create form to add, view or update record.
	The lightning-record-form component provides these helpful features.
o	Switches b/w view and edit modes automatically when the user begins editing a field in a view form.
o	Provide save and cancel buttons automatically in edit form.
o	Use the object default record layout’s with support for multiple columns 
o	Loads all fields in the object compact or full layout or only the fields you specify
	Lightning-record-form is less customizable. To customize the form layout or provide custom rendering of record data, use lightning-record-edit-form(add or update a record) and lightning-record-view-form(view a record )
	Note: whenever possible, to boost performance, define fields instead of layout. Specify layout only when the admin manages.




 
Lightning-record-form kay attributes
1)	object-api-name: This attribute is always required. Specify the object name. Task and Event objects are not supported.
2)	record-id: This attribute is required only when your editing or viewing record.
3)	Fields: Pass record fields as an array of strings. The fields display in the order you list them.
4)	Layout-type: this attribute specify a full or compact layout. 
5)	Modes: this form support 3 modes
a.	Edit
b.	View
c.	Readonly
6)	Columns: use this attribute to shows multiple columns in form.
 
Create a record using Lightning-record-form
Import references to salesforce objects and fields form @salesforce/schema.

Syntax:
Import object name from ‘@salesforce/schema/object reference’
Import field name from ‘@salesforce/schema/object.fieldrefernce’

 
 


 



HTML code:

<template>
    <lightning-card title="Create record using lightning-record-form">
        <lightning-record-form
        object-api-name={objectName}
        fields={fieldList}
        onsuccess={successHandler}
        ></lightning-record-form>
    </lightning-card>

    <lightning-card title="Display record using lightning-record-form">
        <lightning-record-form
        record-id="001N000001zcknoIAA"
        object-api-name={objectName}
        fields={fieldList}
        ></lightning-record-form>
    </lightning-card>

    <lightning-card title="Display record in readonly mode using lightning-record-form">
        <lightning-record-form
        record-id="001N000001zcknoIAA"
        object-api-name={objectName}
        fields={fieldList}
        mode="readonly"
        ></lightning-record-form>
    </lightning-card>

    <lightning-card title="Edit record using lightning-record-form">
        <lightning-record-form
        record-id="001N000001zcknoIAA"
        object-api-name={objectName}
        fields={fieldList}
        mode="edit"
        columns="2"
        ></lightning-record-form>
    </lightning-card>
//If we are using layout then in meta data file we need add record page and edit page object record using app builder added this component in record page. Check video 105 at 23 min 54 sec.

    <lightning-card title="Edit record with layout using lightning-record-form">
        <lightning-record-form
        record-id="001N000001zcknoIAA"
        object-api-name={objectName}
        mode="edit"
        columns="2"
        layout-type="Compact"
        ></lightning-record-form>
    </lightning-card>

</template>


JS code:

import { LightningElement, api } from 'lwc';
import { ShowToastEvent } from 'lightning/platformShowToastEvent';

import ACCOUNT_OBJECT from '@salesforce/schema/Account'
import NAME_FIELD from '@salesforce/schema/Account.Name'
import ANNUAL_REVENUE_FIELD from '@salesforce/schema/Account.AnnualRevenue'
import TYPE_FIELD from '@salesforce/schema/Account.Type'
import INDUSTRY_FIELD from '@salesforce/schema/Account.Industry'
export default class RecordFormDemo extends LightningElement {
    @api recordId
    @api objectApiName
    objectName = ACCOUNT_OBJECT
    fieldList = [NAME_FIELD, ANNUAL_REVENUE_FIELD, TYPE_FIELD, INDUSTRY_FIELD]

    successHandler(event){ 
        console.log(event.detail.id)
        const toastEvent = new ShowToastEvent({ 
            title:"Account created",
            message:"Record ID: "+ event.detail.id,
            variant:"success"
        })
        this.dispatchEvent(toastEvent)
    }
}


Lightning-record-view-form

	Use the lightning-record-view-form component to create form that displays salesforce record data for specified fields associated with that record. The fields are rendered with their labels and current values as read only.
	You can customize the layout or provide custom rendering of record data. If you don’t require customizations , use lightning-record-form instead.
	To specify read-only fields, use lightning-output-field components inside lightning-record-view-form

 

HTML code

<template>
    <lightning-card title="lightning record view form">
        <lightning-record-view-form
        object-api-name="Account"
        record-id="001N000001zcknoIAA"
        >
        <div class="slds-grid slds-gutters">
            <div class="slds-col slds-size_6-of-12">
                <lightning-output-field field-name="Name"></lightning-output-field>// Try to avoid hard code         //values use as per below example.
                <lightning-output-field field-name="Phone"></lightning-output-field>
                <lightning-output-field field-name="Industry"></lightning-output-field>
            </div>
            <div class="slds-col slds-size_6-of-12">
                <lightning-output-field field-name="AnnualRevenue"></lightning-output-field>
            </div>

        </div>

        </lightning-record-view-form>
    </lightning-card>
</template>

JS code
import { LightningElement } from 'lwc';
export default class RecordViewFormDemo extends LightningElement {}


Lightning-record-edit-form

	This component is used to create and edit the records.
	It provides custom layout of fields and custom rendering of record data. If we don’t want customization then use lightning-record-form.
	Here we will use lightning-input-field.

 


HTML code

<template>
    <lightning-card title="lightning record edit form">
        <lightning-record-edit-form 
        object-api-name={objectName}
        >
        <lightning-messages></lightning-messages>// use this tag to display error in component.
    <lightning-input-field field-name={fields.accountField}></lightning-input-field>
    <lightning-input-field field-name={fields.nameField}></lightning-input-field>
    <lightning-input-field field-name={fields.titleField}></lightning-input-field>
    <lightning-input-field field-name={fields.phoneField}></lightning-input-field>
    <lightning-input-field field-name={fields.emailField}></lightning-input-field>
    <lightning-button class="slds-m-around_xx-small" label="cancel"></lightning-button>
    <lightning-button variant="brand" type="submit" class="slds-m-around_xx-small" label="Save"></lightning-button>
    </lightning-record-edit-form>
    </lightning-card>
</template>

JS code

import { LightningElement } from 'lwc';
import CONTACT_OBJECT from '@salesforce/schema/Contact'
import NAME_FIELD from '@salesforce/schema/Contact.Name'
import TITLE_FIELD from '@salesforce/schema/Contact.Title'
import PHONE_FIELD from '@salesforce/schema/Contact.Phone'
import EMAIL_FIELD from '@salesforce/schema/Contact.Email';
import ACCOUNT_FIELD from '@salesforce/schema/Contact.AccountId';
export default class RecordEditForm extends LightningElement {
    objectName = CONTACT_OBJECT
    fields={ 
        accountField:ACCOUNT_FIELD,
        nameField:NAME_FIELD,
        titleField:TITLE_FIELD,
        phoneField:PHONE_FIELD,
        emailField:EMAIL_FIELD
    }
}


Reset the Lightning-record-edit-form

Once we click on the cancel button all fields in the form will be initialize. Refer reset handler method code in below section.

Edit the Lightning-record-edit-form

Refer code in below. If we provide record-id in lightning-record-edit-form then it will fetch the existing records in edit mode otherwise, it will new record creation with blank values.

Adding custom label to the fields in Lightning-record-edit-form

To display custom label in form of existing standard field hide the standard label and add you custom label as shown below example.
HTML code

<template>
    <lightning-card title="lightning record edit form">
        <lightning-record-edit-form 
        object-api-name={objectName}
        record-id="003N000001mL1V4IAK"
        >
        <lightning-messages></lightning-messages>
    <lightning-input-field field-name={fields.accountField}></lightning-input-field>
    <lightning-input-field field-name={fields.nameField}></lightning-input-field>
    <lightning-input-field field-name={fields.titleField}></lightning-input-field>
    <lightning-input-field field-name={fields.phoneField}></lightning-input-field>
    <label class="slds-p-left_x-small">Enter your email</label>
    <lightning-input-field variant="label-hidden" field-name={fields.emailField}></lightning-input-field>         // To display custom label in form hide the standard labal and add you custom label as shown above
    <lightning-button onclick={handleReset} class="slds-m-around_xx-small" label="cancel"></lightning-button>
    <lightning-button variant="brand" type="submit" class="slds-m-around_xx-small" label="Save"></lightning-button>
    </lightning-record-edit-form>
    </lightning-card>
</template>

JS code

import { LightningElement } from 'lwc';
import CONTACT_OBJECT from '@salesforce/schema/Contact'
import NAME_FIELD from '@salesforce/schema/Contact.Name'
import TITLE_FIELD from '@salesforce/schema/Contact.Title'
import PHONE_FIELD from '@salesforce/schema/Contact.Phone'
import EMAIL_FIELD from '@salesforce/schema/Contact.Email';
import ACCOUNT_FIELD from '@salesforce/schema/Contact.AccountId';
export default class RecordEditForm extends LightningElement {
    objectName = CONTACT_OBJECT
    fields={ 
        accountField:ACCOUNT_FIELD,
        nameField:NAME_FIELD,
        titleField:TITLE_FIELD,
        phoneField:PHONE_FIELD,
        emailField:EMAIL_FIELD
    }
    handleReset(){ 
        const inputFields = this.template.querySelectorAll('lightning-input-field')
        if(inputFields){ 
            Array.from(inputFields).forEach(field=>{ 
                field.reset()
            })
        }
    }
}

Custom validations in Lightning-record-edit-form

HTML code

<template>
    <lightning-card title="Custom validation in lightning record edit form">
        <lightning-record-edit-form
        object-api-name={objectName}
        onsubmit={handleSubmit}
        onsuccess={successHandler}
        onerror={handleError}
        >
        <lightning-input label="Name"
        value={inputValue}
        onkeyup={handleChange}
        class="slds-m-bottom_x-small"></lightning-input>

        <lightning-button class="slds-m-top_small" type="submit" label="Create Account"></lightning-button>
        </lightning-record-edit-form>
    </lightning-card>
</template>


JS code

import { LightningElement } from 'lwc';
import ACCOUNT_OBJECT from '@salesforce/schema/Account'
import { ShowToastEvent } from 'lightning/platformShowToastEvent';

export default class RecordEditCustom extends LightningElement {
    objectName = ACCOUNT_OBJECT
    inputValue=''
    handleChange(event){ 
        this.inputValue = event.target.value
    }

    handleSubmit(event){ 
        event.preventDefault()
        const inputCmp = this.template.querySelector('lightning-input')
        const value= inputCmp.value
        if(!value.includes('Australia')){ 
            inputCmp.setCustomValidity("The account name must include 'Australia'")
        } else { 
            inputCmp.setCustomValidity("")
            const fields = event.detail.fields
            fields.Name = value
            this.template.querySelector('lightning-record-edit-form').submit(fields)
        }
        inputCmp.reportValidity()

    }
    successHandler(event){ 
        const toastEvent = new ShowToastEvent({ 
            title:"Account created",
            message: "Record ID: "+ event.detail.id,
            variant:"success"
        })
        this.dispatchEvent(toastEvent)

    }
    handleError(event){ 
        const toastEvent = new ShowToastEvent({ 
            title:"Error creating Account",
            message: event.detail.message,
            variant:"error"
        })
        this.dispatchEvent(toastEvent)
    }
}

14)	Lightning data service Wire adaptors and functions


	Use this to get raw record data like Picklist, Record info, object info etc.
	Want more customization to create a forms
	You want to perform business logics. 	

 
	The wire adapters and java functions are available in ‘Lightning/ui*Api’  modules. Which are built on user interface API. User interface API supports all custom objects and many standard objctes.
	This module dived into 4 types,
o	Lightning/uiObjectInfoApi : use to get object metadata and get picklist values
In these below adapters will come.
•	getObjectInfo adapter
•	getObjectInfos adapter
•	getPicklistValues adapter
•	getPicklistValuesByRecordType adapter

o	Lightning/uiListApi(Beta): Get the records and metadata for a list view. 
	getListUi adapter
o	Lightning/uiRecordApi: Use to record data and get default values to create records. It also includes java script API’s to create, delete, update and refresh records.( Without wring JS code)
	getRecord adapter

o	Lightning/ui AppApi(Beta): use to get data and metadata for apps displayed in the salesforce
	getNavItems adapter	
									

 



@wire service and fetch user details

	Wire service is built on the Lightning data service.
	LWC component use @wire in their java script class to read data from one of the wire adapters in the Lightning/ui*Api namespace.
	@wire is reactive service.
	The wire adaptor defines the data shape that the wire service provisions in an immutable steam.


Syntax: it will import adapter id from adaptermodule (i.e lightning/ui*Api) then we will pass these to @wire() then we will configure property or function to listen.
Import {adapter id } from ‘adapterModule’;
@wire(adapterId, adapterConfig)
PropertyOrfunction;

 


HTML code:

<template>
    <lightning-card title="User detail using wire as function">
        <div class="slds-var-p-around_medium">
            <template if:true={userDetail}>
                <div>Email - {userDetail.Email.value}</div>
                <div>Name - {userDetail.Name.value}</div>
            </template>
        </div>
    </lightning-card>
    <lightning-card title="User detail using wire as property">
        <div class="slds-var-p-around_medium">
             <template if:true={userDetailProperty.data}>
                <div>Email - {userDetailProperty.data.fields.Email.value}</div>
                <div>Name - {userDetailProperty.data.fields.Name.value}</div>
            </template>
        </div>
    </lightning-card>
</template>


JS code:


import { LightningElement, wire } from 'lwc';
import {getRecord} from 'lightning/uiRecordApi'
import Id from '@salesforce/user/Id'
import NAME_FIELD from '@salesforce/schema/User.Name'
import EMAIL_FIELD from '@salesforce/schema/User.Email'
const fields = [NAME_FIELD, EMAIL_FIELD]
export default class WireDemoUserDetail extends LightningElement {
    userId = Id

    userDetail
    @wire(getRecord, {recordId:'0050p000002MXU6AAO', fields})
    userDetailHandler({data, error}){
        if(data){
            this.userDetail = data.fields
        }
        if(error){
            console.error(error)
        }
    }
// in below we are passing getrecord adapter and passing record id from where we need to fetch the details and whatever the field required.
    @wire(getRecord, {recordId:'0050p000002MXU6AAO', fields})
    userDetailProperty
}


To import object reference:

 



To import object field reference:


 



How @wire is reactive service:


HTML code:


<template>
    <lightning-card title="User detail using wire as function">
        <div class="slds-var-p-around_medium">
            <template if:true={userDetail}>
                <div>Email - {userDetail.Email.value}</div>
                <div>Name - {userDetail.Name.value}</div>
            </template>
        </div>
    </lightning-card>
    <lightning-card title="User detail using wire as property">
        <div class="slds-var-p-around_medium">
            <template if:true={userDetailProperty.data}>
                <div>Email - {userDetailProperty.data.fields.Email.value}</div>
                <div>Name - {userDetailProperty.data.fields.Name.value}</div>
            </template>
        </div>
    </lightning-card>
</template>



JS code

In below code if try to use Userid that is imported in @wire method then it will throw error because Import is asynchronous process before getting the value to this field, @wire method will execute but getrecord adapter will  expecte record id to be passed to get the details.


 


Reactive means once data available immediately update. To make property Reactive we need to use ‘$propertyname’. 

import { LightningElement, wire } from 'lwc';
import {getRecord} from 'lightning/uiRecordApi'
import Id from '@salesforce/user/Id'
import NAME_FIELD from '@salesforce/schema/User.Name'
import EMAIL_FIELD from '@salesforce/schema/User.Email'
const fields = [NAME_FIELD, EMAIL_FIELD]
export default class WireDemoUserDetail extends LightningElement {
    userId = Id

    userDetail
    @wire(getRecord, {recordId:'$userId', fields})
    userDetailHandler({data, error}){
        if(data){
            this.userDetail = data.fields
        }
        if(error){
            console.error(error)
        }
    }

    @wire(getRecord, {recordId:'$userId', fields})
    userDetailProperty
}


getObjectInfo adapter

	This adapter we will import from ‘lightning/uiObjectInfoApi’. 
	Use this wire adapter to get metadata about specific object. The response includes metadata describing the object fields, child relationships, record type and theme.

 

HTML Code
<template>
    <lightning-card title="getObjectInfo Adapter">
        <div class="slds-var-p-around_medium">
            <template if:true={objectInfo.data}>
                <div>defaultRecordTypeId: {objectInfo.data.defaultRecordTypeId}</div>
                <div>Object API Name: {objectInfo.data.apiName}</div>
            </template>
        </div>
    </lightning-card>
</template>

JS

import { LightningElement, wire } from 'lwc';
import {getObjectInfo} from 'lightning/uiObjectInfoApi'
import ACCOUNT_OBJECT from '@salesforce/schema/Account'
export default class GetObjectInfoDemo extends LightningElement {

    @wire(getObjectInfo, {objectApiName:ACCOUNT_OBJECT})
    objectInfo
}


Same example with Function:

HTML code:

    <lightning-card title="getobject information with function">
        <template if:true={objectin}>
            <div> default record type is : {objectin.defaultRecordTypeId}</div>
            <div> object name is : {objectin.apiName}</div>
        </template>
        <template if:false={objectin}>
            <div> no data found</div>
        </template>
    </lightning-card>

JS code:
    @wire(getObjectInfo, {objectApiName: ACCOUNT_OBJECT})
    AccountInfo(data, error){
        if(data){
            console.log('account object infor', data)    
            this.objectin = data.data
            console.log('record type is : ', this.objectin)            
        }else{
            console.error(error)
        }        

    }    


 
getObjectInfos adapter

	This adapter we will import from ‘lightning/uiObjectInfoApi’. 
	Use this wire adapter to get metadata for multiple objects. The response includes metadata describing the object fields, child relationships, record type and theme for each object.
 


HTML Code

<template>
    <lightning-card title="getObjectInfo Adapter">
        <div class="slds-var-p-around_medium">
            <template if:true={objectInfo.data}>
                <div>defaultRecordTypeId: {objectInfo.data.defaultRecordTypeId}</div>
                <div>Object API Name: {objectInfo.data.apiName}</div>
            </template>
        </div>
    </lightning-card>

    <lightning-card title="getObjectInfos Adapter">
        <div class="slds-var-p-around_medium">
            <template if:true={objectInfos}>
                <template for:each={objectInfos.results} for:item="obj">
                    <div key={obj.result.apiName}>
                        <div>Object Api Name - {obj.result.apiName}</div>
                        <div>defaultRecordTypeId - {obj.result.defaultRecordTypeId}</div>
                    </div>
                </template>
            </template>
            
        </div>
    </lightning-card>

    
</template>

JS
import { LightningElement, wire } from 'lwc';
import {getObjectInfo, getObjectInfos} from 'lightning/uiObjectInfoApi'
import ACCOUNT_OBJECT from '@salesforce/schema/Account'
import OPPORTUNITY_OBJECT from '@salesforce/schema/Opportunity'
export default class GetObjectInfoDemo extends LightningElement {

    @wire(getObjectInfo, {objectApiName:ACCOUNT_OBJECT})
    objectInfo

    objectApiNames = [ACCOUNT_OBJECT, OPPORTUNITY_OBJECT]
// to get the multiple object information we should use the $object name then only it will work otherwise it will not return data.
//    @wire(getObjectInfos, { objectApiNames: [ACCOUNT_OBJECT, OPPORTUNITY_OBJECT] })
If we use wire like this then it will also will return data.

    objectInfos
    @wire(getObjectInfos, { objectApiNames: '$objectApiNames' })
    objectInfosHandler({data}){
        if(data){
            console.log(data)
            this.objectInfos = data
        }
    }
}

getPicklistValues adapter

	This adapter we will import from ‘lightning/uiObjectInfoApi’. 
	Use this wire adapter to get a picklist values for specific field.
	Before to this adapter we used to write apex to get the picklist values but with this adapter we will get picklist values without writing apex code.


 

HTML Code

<template>
    <lightning-card title="getPicklistValues Demo">
        <div class="slds-var-p-around_medium">
            <lightning-combobox
            name="Industry"
            label="Industry"
            value={selectedIndustry}
            placeholder="Select Industry"
            options={industryOptions}
            onchange={handleChange} ></lightning-combobox>
        </div> 
        <p>selectedIndustry:{selectedIndustry}</p>
    </lightning-card>

    <lightning-card title="getPicklistValues Demo with type">
        <div class="slds-var-p-around_medium">
            <lightning-combobox
            name="Type"
            label="Type"
            value={selectedType}
            placeholder="Select Type"
            options={typeOptions}
            onchange={handleTypeChange} ></lightning-combobox>
        </div> 
        <p>selectedType:{selectedType}</p>
    </lightning-card>
</template>


JS

import { LightningElement, wire } from 'lwc';
import { getObjectInfo, getPicklistValues} from 'lightning/uiObjectInfoApi'
import INDUSTRY_FIELD from '@salesforce/schema/Account.	
import TYPE_FIELD  from '@salesforce/schema/Account.Type'
import ACCOUNT_OBJECT from '@salesforce/schema/Account'
export default class GetPIcklistValuesDemo extends LightningElement {
    selectedIndustry = '';
    selectedType=''
    industryOptions=[]
    typeOptions=[]
    @wire(getObjectInfo, {objectApiName:ACCOUNT_OBJECT})
    objectInfo

    @wire(getPicklistValues, { recordTypeId:'$objectInfo.data.defaultRecordTypeId', fieldApiName:INDUSTRY_FIELD})
    industryPicklist({data, error}){
        if(data){
            console.log(data)
            this.industryOptions = [...this.generatePicklist(data)]
        }
        if(error){
            console.error(error)
        }
    }
    generatePicklist(data){
        return data.values.map(item=>({ label: item.label, value: item.value }))
    }
    handleChange(event) {
        this.selectedIndustry = event.detail.value;
    }
    /***second picklist for type */
    @wire(getPicklistValues, { recordTypeId:'$objectInfo.data.defaultRecordTypeId', fieldApiName:TYPE_FIELD})
    typePicklist({data, error}){
        if(data){
            console.log(data)
            this.typeOptions = [...this.generatePicklist(data)]
        }
        if(error){
            console.error(error)
        }
    }
    handleTypeChange(event) {
        this.selectedType = event.detail.value;
    }
}


getPicklistValuesByRecordType adapter

	This adapter we will import from ‘lightning/uiObjectInfoApi’. 
	Use this wire adapter to get the values for every picklist of a specified record type in the object.
 
 



HTML Code
<template>
    <lightning-card title="getPicklistValuesByRecordType Adapter">
        <div class="slds-var-p-around_medium">
            <template if:true={ratingOptions}>
                <lightning-combobox
                name="rating"
                label="Rating"
                value={selectedRating}
                placeholder="Select Rating"
                options={ratingOptions}
                onchange={handleChange}></lightning-combobox>
                <p>selectedRating: {selectedRating}</p>
            </template>
            
            <template if:true={industryOptions}>
                <lightning-combobox
                name="industry"
                label="Industry"
                value={selectedIndustry}
                placeholder="Select Industry"
                options={industryOptions}
                onchange={handleChange}></lightning-combobox>
                <p>selectedIndustry: {selectedIndustry}</p>
            </template>
        </div>
    </lightning-card>
</template>

JS

import { LightningElement, wire } from 'lwc';
import {getPicklistValuesByRecordType, getObjectInfo} from 'lightning/uiObjectInfoApi'
import ACCOUNT_OBJECT from '@salesforce/schema/Account'
export default class GetPicklistValuesByRecordTypeDemo extends LightningElement {
    ratingOptions
    industryOptions
    selectedRating
    selectedIndustry
    @wire(getObjectInfo, {objectApiName:ACCOUNT_OBJECT})
    objectInfo

    @wire(getPicklistValuesByRecordType, {objectApiName:ACCOUNT_OBJECT, 
        recordTypeId:'$objectInfo.data.defaultRecordTypeId'})
        picklistHandler({data, error}){
            if(data){
                console.log(data)
                this.ratingOptions = this.picklistGenerator(data.picklistFieldValues.Rating)
                this.industryOptions = this.picklistGenerator(data.picklistFieldValues.Industry)
            }
            if(error){
                console.error(error)
            }
        }

    picklistGenerator(data){
        return data.values.map(item=>({"label":item.label, "value":item.value}))
    }

    handleChange(event){
        const {name, value} = event.target
        console.log(name +'==>' +value)
        if(name === 'industry'){
            this.selectedIndustry = value
        }
        if(name === 'rating'){
            this.selectedRating = value
        }
    }
}

getRecord adapter

	This adapter we will import from ‘lightning/uiRecordApi’. 
	Use this wire adapter to get the record’s data only these will not return metadata.
Syntax:
Import {getRecord} from ‘lightning/uiRecordApi’
@wire(getRecor, {recordId: string, fields:string|string[], optinalFields?: string|string[]})
Property or Function
Or 

@wire(getRecor, {recordId: string, layoutTypes:string|string[], optinalFields?: string|string[]})
Property or Function


RecordId: the Id of the record type.
Fields: a field or array of fields to return. If we field is accessible to user then it includes in response otherwise it will throw an error. Or Layout: it supports compact or full(default).
Modes: used with layout. Supported are create, edit and View(default).
OptionalFiields: a field name or an array of field names. If we field is accessible to user then it includes in response otherwise it will not throw an error and also that field not included in the response.


 

When we get the record data using getRecord adapter the data will be in the below form so for field we will have display value and value.
 

HTML Code
<template>
    <lightning-card title="getRecord Adapter">
        <div class="slds-p-around_medium">
            <div>Name - {name}</div>
            <div>owner - {owner}</div>
            <div>AnnualRevenue - {AnnualRevenue}</div>
        </div>
    </lightning-card>
</template>

JS

import { LightningElement, wire, api } from 'lwc';
import {getRecord} from 'lightning/uiRecordApi'
import NAME_FIELD from '@salesforce/schema/Account.Name'
import OWNER_NAME_FIELD from '@salesforce/schema/Account.Owner.Name'
import ANNUAL_REVENUE_FIELD from '@salesforce/schema/Account.AnnualRevenue'
export default class GetRecordDemo extends LightningElement {
    name
    owner
    AnnualRevenue
    @api recordId
    // @wire(getRecord, {recordId:'$recordId',
    //  fields:[NAME_FIELD, OWNER_NAME_FIELD, ANNUAL_REVENUE_FIELD]})
    @wire(getRecord, {recordId:'$recordId',
     layoutTypes:['Full'], modes:['View']})
     accountHandler({data}){
         if(data){
             console.log(data)
             this.name = data.fields.Name.displayValue ? data.fields.Name.displayValue:
             data.fields.Name.value
             this.AnnualRevenue = data.fields.AnnualRevenue.displayValue ? data.fields.AnnualRevenue.displayValue:
             data.fields.AnnualRevenue.value
             this.owner = data.fields.Owner.displayValue ? data.fields.Owner.displayValue:
             data.fields.Owner.value

         }
     }
}

getFieldValue & getFieldDisplayvalue functions

 

When we get the record data using getRecord adapter the data will be in the below form so for field we will have display value and value. Based on our requirement we will use getFieldValue & getFieldDisplayvalue functions.
 



HTML Code

<template>
    <lightning-card title="getRecord Adapter">
        <div class="slds-p-around_medium">
            <div>Name - {name}</div>
            <div>owner - {owner}</div>
            <div>AnnualRevenue - {AnnualRevenue}</div>
        </div>
    </lightning-card>
</template>


JS

import { LightningElement, wire, api } from 'lwc';
import {getRecord, getFieldValue, getFieldDisplayValue} from 'lightning/uiRecordApi'
import NAME_FIELD from '@salesforce/schema/Account.Name'
import OWNER_NAME_FIELD from '@salesforce/schema/Account.Owner.Name'
import ANNUAL_REVENUE_FIELD from '@salesforce/schema/Account.AnnualRevenue'
export default class GetRecordDemo extends LightningElement {
    name
    owner
    AnnualRevenue
    @api recordId
    @wire(getRecord, {recordId:'$recordId',
     fields:[NAME_FIELD, OWNER_NAME_FIELD, ANNUAL_REVENUE_FIELD]})
     accountHandler({data}){
         if(data){
             console.log(data)
             this.name = getFieldValue(data, NAME_FIELD) 
             this.AnnualRevenue = getFieldDisplayValue(data, ANNUAL_REVENUE_FIELD) 
             this.owner = getFieldValue(data, OWNER_NAME_FIELD) 

         }
     }
}

getRecordUi adapter

	This adapter we will import from ‘lightning/uiRecordApi’. 
	Use this wire adapter to get the layout information, metadata and data to build UI for one or more records.

Import {getRecordUi} from ‘lightning/uiRecordApi’
@wire(getRecordUi, {recordIds: string|String[] , layoutTypes:string|string[], modes: string|string[],  optinalFields?: string|string[]})
Property or Function

RecordIds: the Ids of the records to loead.
Layout: it supports compact or full(default).
Modes: used with layout. Supported are create, edit and View(default).
OptionalFiields: a field name or an array of field names. If we field is accessible to user then it includes in response otherwise it will not throw an error and also that field not included in the response.
 
 
By using getrecord adapter we will get only record data. If we use getRecordUi adapter we will get layout , metadata and record data information like below. We can expand to see more info.
 

HTML Code
<template>
    <lightning-card title="getRecordUi demo">
        <div class="slds-p-around_medium">
            <template for:each={formFields} for:item="field">
                <div key={field.label}>
                    <p><strong>{field.label}</strong></p>
                    <p>{field.value}</p>
                </div>
            </template>
        </div>
    </lightning-card>
</template>

JS

import { LightningElement, wire, api } from 'lwc';
import {getRecordUi} from 'lightning/uiRecordApi'
export default class GetRecordUiDemo extends LightningElement {
    formFields=[
        {"fieldName":"AccountNumber", "label":"Account Number"},
        {"fieldName":"AnnualRevenue", "label":"Annual Revenue"},
        {"fieldName":"Name", "label":"Name"},
        {"fieldName":"Phone", "label":"Phone"}
    ]
    @api recordId
    @wire(getRecordUi, {recordIds:'$recordId', layoutTypes:'Full', modes:'Edit'})
    accountRecordUiHandler({data, error}){
        if(data){
            console.log(data)
            this.formFields = this.formFields.map(item=>{
                return {...item, value:data.records[this.recordId].fields[item.fieldName].value}
            })
        } 
        if(error){
            console.error(error)
        }
    }
}

createRecord function 

	This function we will import from ‘lightning/uiRecordApi’. 
	This function will use to create a record and this function will return the promise.
Syntax:
Import {createrecord} from ‘lightning/uiRecordApi’
createRecord( recordInput : Record) : promise<record>

recordInput: A record input object is used to create the record. This object take object apiName and Field details as input. Like below.
const recordInput = {apiName:CONTACT_OBJECT.objectApiName, fields:this.formFields}
createRecord(recordInput).then(result=>{
}

 

HTML Code

<template>
    <lightning-card title="create record form demo">
        <div class="slds-p-around_medium">
            <form class="createForm">
                <lightning-input label="First Name" name="FirstName"
                 onchange={changeHandler} class="slds-m-bottom_x-small"></lightning-input>
                 <lightning-input label="Last Name" name="LastName"
                 onchange={changeHandler} class="slds-m-bottom_x-small"></lightning-input>
                 <lightning-input label="Title" name="Title"
                 onchange={changeHandler} class="slds-m-bottom_x-small"></lightning-input>
                 <lightning-input type="tel" label="Phone" name="Phone"
                 onchange={changeHandler} class="slds-m-bottom_x-small"></lightning-input>
                 <lightning-input type="email" label="Email" name="Email"
                 onchange={changeHandler} class="slds-m-bottom_x-small"></lightning-input>
                 <lightning-button label="Create Contact" variant="brand" onclick={createContact}></lightning-button>
            </form>
        </div>
    </lightning-card>
</template>

JS

import { LightningElement } from 'lwc';
import {createRecord} from 'lightning/uiRecordApi'
import CONTACT_OBJECT from '@salesforce/schema/Contact'
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
export default class CreateRecordDemo extends LightningElement {
    formFields={}
    changeHandler(event){
        const {name, value} = event.target
        this.formFields[name]=value
    }
    createContact(){
        const recordInput = {apiName:CONTACT_OBJECT.objectApiName, fields:this.formFields}
        createRecord(recordInput).then(result=>{
            this.showToast('Success!!', `contact created with is ${result.id}`)
            this.template.querySelector('form.createForm').reset()
            this.formFields={}
        }).catch(error=>{
            this.showToast('Error Creating record', error.body.message, 'error')
        })
    }

    showToast(title, message, variant){
        this.dispatchEvent(new ShowToastEvent({
            title,
            message,
            variant:variant || 'success'
        }))
    }
}

updateRecord function

	This function we will import from ‘lightning/uiRecordApi’. 
	This function will use to update the record and this function will return the promise.
Syntax:
Import {updaterecord} from ‘lightning/uiRecordApi’
updateRecord( recordInput : Record, clientOptions?: Object) : promise<record>

recordInput: A record input object is used to update the record. This object take object apiName and Field details as input. 
clientOptions?-(Optional):  to check for conflicts before you update the record. 

 

HTML Code

<template>
    <lightning-card title="Update Record Demo">
        <div class="slds-p-around_medium">
            <lightning-datatable
                key-field="Id"
                data={contacts}
                columns={columns}
                draft-values={draftValues}
                onsave={handleSave}
                hide-checkbox-column>
            </lightning-datatable>
        </div>
    </lightning-card>
</template>

JS: Draft vales: suppose we have edited some fields inline in List view and these values will store in some cache before saving to data base that’s called draft values.

import { LightningElement, wire } from 'lwc';
import {getListUi} from 'lightning/uiListApi'
import { updateRecord  } from 'lightning/uiRecordApi';
import CONTACT_OBJECT from '@salesforce/schema/Contact'
const COLS =[
    {label:'Id', fieldName:'Id'},
    {label:'Name', fieldName:'Name'},
    {label:'Title', fieldName:'Title'},
    {label:'Phone', fieldName:'Phone', editable:true},
    {label:'Email', fieldName:'Email', type:'email', editable:true}
]
export default class UpdateRecordDemo extends LightningElement {
    contacts=[]
    columns = COLS
    draftValues=[]
    @wire(getListUi, {
        objectApiName:CONTACT_OBJECT,
        listViewApiName:'AllContacts'
    })listViewHandler({data, error}){
        if(data){
            console.log(data)
            this.contacts = data.records.records.map(item=>{
                return {
                    "Id": this.getValue(item, 'Id'),
                    "Name": this.getValue(item, 'Name'),
                    "Title": this.getValue(item, 'Title'),
                    "Phone": this.getValue(item, 'Phone'),
                    "Email": this.getValue(item, 'Email')
                }
            })
        }
        if(error){
            console.error(error)
        }
    }

    getValue(data, field){
        return data.fields[field].value
    }

    handleSave(event){
        console.log(JSON.stringify(event.detail.draftValues))
        const recordInputs=event.detail.draftValues.map(draft=>{
            const fields = {...draft};
            return { fields:fields };
        })
        const promises = recordInputs.map(recordInput=>updateRecord(recordInput))
        Promise.all(promises).then(()=>{
            console.log('COntact updated Successfully')
            this.draftValues=[]
        }).catch(error=>{
            console.error("Error updating the record", error)
        })
        
    }
}

deleteRecord function 

	This function we will import from ‘lightning/uiRecordApi’. 
	This function will use to delete the record and it will return promise.

 

HTML Code
 
<template>
  <lightning-card title="delete record demo">
      <div class="slds-p-around_medium">
          <form>
              <lightning-input label="Record Id" name="recordId" 
              onchange={changeHandler} class="slds-m-bottom_x-small"></lightning-input>
              <lightning-button label="Delete record" variant="brand" onclick={deleteHandler}></lightning-button>
          </form>
      </div>
  </lightning-card>  
</template>

JS

import { LightningElement } from 'lwc';
import {deleteRecord} from 'lightning/uiRecordApi'
import { ShowToastEvent } from 'lightning/platformShowToastEvent';
export default class DeleteRecordDemo extends LightningElement {
    recordId
    changeHandler(event){
       this.recordId = event.target.value
    }
    deleteHandler(){
        deleteRecord(this.recordId).then(()=>{
            this.showToast("Sucess!!", "Deleted Successfully!!", 'success')
        }).catch(error=>{
            console.error(error)
            this.showToast("Error!!", "Error Occurred!!", 'error')
        })
    }
    showToast(title, message, variant){
        this.dispatchEvent(new ShowToastEvent({
            title,
            message,
            variant
        }))
    }
}







getListUi adapter

	This adapter we will import from ‘lightning/uiListApi’. 
	Use this wire adapter to get the records and metadata for a list view.
	With this adapter we can give sortBy, pageSize , pageToken(pagination).
	This is only evolution purpose only, not in production use
 

HTML Code

<template>
    <lightning-card title="getListUi Demo">
        <div class="slds-var-p-around_medium">
            <table class="slds-table slds-table_cell-buffer slds-table_bordered">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Email</th>
                        <th>Title</th>
                    </tr>
                </thead>
                <tbody>
                    <template for:each={contacts} for:item="contact">
                        <tr key={contact.fields.Id.Value}>
                            <td>{contact.fields.Name.value}</td>
                            <td>{contact.fields.Email.value}</td>
                            <td>{contact.fields.Title.value}</td>
                        </tr>
                    </template>
                </tbody>
            </table>
        </div>
        <div class="slds-grid">
            <div class="slds-m-around_medium">
                <lightning-button label="Previous" onclick={handlePreviousPage}></lightning-button>
            </div>
            <div class="slds-m-around_medium">
                <lightning-button label="Next" onclick={handleNextPage}></lightning-button>
            </div>
        </div>
    </lightning-card>
</template>

JS

import { LightningElement, wire } from 'lwc';
import {getListUi} from 'lightning/uiListApi'
import CONTACT_OBJECT from '@salesforce/schema/Contact'
import TITLE_FIELD from '@salesforce/schema/Contact.Title'
export default class GetListUiDemoLwc extends LightningElement {
    contacts=[]
    pageToken = null
    nextPageToken = null
    previousPageToken = null
    @wire(getListUi, {
        objectApiName:CONTACT_OBJECT,
        listViewApiName:'AllContacts',
        pageSize:10,
        sortBy:TITLE_FIELD,
        pageToken:'$pageToken'// here whenever value changes and this method will execute again. So      initially this value is ero so it will display first 10 record once we click on next button then the value will updte and next 10 fetch and display/
    })
    listViewHandler({data, error}){
        if(data){
            console.log(data)
            this.contacts = data.records.records
            this.nextPageToken = data.records.nextPageToken
            this.previousPageToken = data.records.previousPageToken
        }
        if(error){
            console.error(error)
        }
    }
    handlePreviousPage(){
        this.pageToken = this.previousPageToken
    }
    handleNextPage(){
        this.pageToken = this.nextPageToken
    }
}

getNavItems adapter

	This adapter we will import from ‘lightning/uiAppsApi’. 
	Use this wire adapter to retrieve the items in the navigation menu.
	This is only evolution purpose only, not in production use.
 
HTML Code

<template>
    <lightning-card title="getNavItems Demo">
        <div class="slds-p-around_medium">
           <template if:true={result}>
               <div>developerName - {result.developerName}</div>
               <div>objectApiName- {result.objectApiName}</div>
               <div>pageReference- {result.pageReference.type}</div>
           </template>
        </div>
    </lightning-card>
</template>

JS

import { LightningElement, wire } from 'lwc';
import {getNavItems} from 'lightning/uiAppsApi'
export default class GetNavItemsDemo extends LightningElement {
    result
    @wire(getNavItems, {
        navItemNames:['standard-Account'],
        pageSize:30
    })
    navItemsHandler({data}){
        if(data){
            console.log(data)
            this.result = data.navItems[0]
        }
    }
}

Life cycle of @wire Adopters 

Example:
import { LightningElement, wire, api } from 'lwc';
import { getRecord, getFieldValue } from 'lightning/uiRecordApi';
import NAME_FIELD from '@salesforce/schema/MyCustomObject__c.Name';

export default class DoTheThing extends LightningElement {
    recordId = 'a073i0000049kNMAAY';

    @wire(getRecord, {recordId:'$recordId', fields: [NAME_FIELD]})
    myWiredRecord ({data, error}){
        debugger;
        if(data){
            debugger;
            //codigo
        }
    }
}


	The first thing executed here is the constructor. At this point, properties are set, for example the recordId.
	Just after the constructor, and before any other LWC lifecycle event, the wire service sends a default object like the following {data: undefined, error: undefined}.
	This default object is responsible at making the browser stop at lindeb 10 debugger and showing undefined as the value for data.
	connectedCallback is executed, and after it, the @wire is called again. This time @wire consumes the values stored in recordId and [NAME_FIELD]. And so, data or error values will be modified and in case everything worked accordingly the line 12 debugger will force the browser to stop.
So, Our example lifecycle will be something like this:

o	constructor
o	Properties are set
o	wire service sends a default object {data: undefined, error: undefined}
o	Line 10 debugger
o	connectedCallback
o	wire service returns a new record, but this time the wire service is using the info stored in recordId and [NAME_FIELD] and bringing that value from the cache or server
o	Line 10 debugger
o	wire service returns data
o	Line 12 debugger
15)	Apex in LWC


For example, when you want to customize a single-record data transaction, or perform multi-record operations on a single transaction, Apex is the best choice.
 





 



 



Expose Apex method to LWC
	To expose Apex method to LWC we need to use @AuraEnabled annotation and methd must be static and either public or global.

 

An Apex method used in a Lightning web component must be static, public or global, and annotated with @AuraEnabled immediately before the method definition. The @AuraEnabled annotation makes the Apex method available to Lightning components (both Lightning web components and Aura components).
Allowing the framework to cache data eliminates repeated server calls making future read operations run faster. We mark a method as cacheable by setting cacheable = true in the @AuraEnabled annotation. When an @AuraEnabled method is cacheable, Data Manipulation Language (DML) operations are not allowed.
When a method is cacheable, newly added or changed versions of records may not be returned until the cache is refreshed.



Apex code:

public with sharing class AccountController {
    @AuraEnabled(cacheable=true)
    public static List<Account> getAccountList(){
        return [SELECT Id, Name, Type, Industry from Account LIMIT 5];
    }
}
HTML code 

JS code 


Import Apex methods
	To import apex method use default import syntax in javascript via ‘@salesforce/apex’ scoped packages

Syntax:
Import apexmethodname from ‘@salesforce/apex/namespace.classname.apexmethodrefernce’



 


Wire Apex method

To wire an Apex method, the method must be cacheable. To wire a cacheable Apex method, use the @wire decorator (the same way you use an LDS wire adapter). Calling Apex this way delegates control to the Lightning Web Components engine and creates a reactive service. Every time the value of a parameter that’s passed to the Apex method changes, the Apex method provisions the new value to the decorated property or function. Because wired methods must be cacheable, data can come from the LDS cache or the server. To refresh the data that was cached by an Apex method, call the refreshApex function.
Note: Lightning Data Service is unaware of the data that's cached by Apex methods. When an LDS function updates a record, that update has no impact on data that was cached by an Apex method.



	We can write wire apex in 2 ways
o	Wire apex method to a property
o	Wire apex method to a function

Syntax:
Import apexmethodname from ‘@salesforce/apex/namespace.classname.methodrefernce’
@wire(apexmethodname, {Apexmethodparams})
Property or function

Apexmethodname: a symbol that identifies the apex method
ApexmethodParams: an object with parameters that match parameters of the apex method.
Note: If parameter value is null then it will call the method, if parameter values undefined then it will not call method.

 

HTML code 

<template>
    <lightning-card title="Apex Wire To Property Demo">
        <div class="slds-p-around_medium">
            <template if:true={accounts.data}>
                <template for:each={accounts.data} for:item="account">
                    <div class="slds-box slds-box_xx-small" key={account.Id}>
                        <p><strong>Name : </strong> {account.Name}</p>
                        <p><strong>Type : </strong> {account.Type}</p>
                        <p><strong>Industry : </strong> {account.Industry}</p>
                    </div>
                </template>
               
            </template>
        </div>
    </lightning-card>
    <lightning-card title="Apex Wire To Function Demo">
        <div class="slds-p-around_medium">
            <template if:true={accountList}>
                <template for:each={accountList} for:item="account">
                    <div class="slds-box slds-box_xx-small" key={account.Id}>
                        <p><strong>Name : </strong> {account.Name}</p>
                        <p><strong>Type : </strong> {account.newType}</p>
                        <p><strong>Industry : </strong> {account.Industry}</p>
                    </div>
                </template>
               
            </template>
        </div>
    </lightning-card>
</template>

JS code 

import { LightningElement, wire } from 'lwc';
import getAccountList from '@salesforce/apex/AccountController.getAccountList'
export default class ApexWireDemo extends LightningElement {
    accountList
    
    @wire(getAccountList)
    accounts

    
    @wire(getAccountList)
    accountsHandler({data, error}){
        if(data){
            this.accountList = data.map(item=>{
                let newType = item.Type === 'Customer - Channel' ? 'Channel': //we have a requirement whenever type 'Customer - Channel' print as channel only and 'Customer - Directl' to direct only.
                item.Type === 'Customer - Direct' ? 'Direct':'-------'
                return {...item, newType}
            })
        }
        if(error){
            console.error(error)
        }
    }
}

Apex code 

public with sharing class AccountController {
    @AuraEnabled(cacheable=true)
    public static List<Account> getAccountList(){
        return [SELECT Id, Name, Type, Industry from Account LIMIT 5];
    }
}


Wire Apex method with parameters

HTML code 
<template>
    <lightning-card title="Apex Wire Demo with params">
        <div class="slds-var-p-around_medium">
            <lightning-combobox
                name="type"
                lable="Choose your Type"
                value={selectedType}
                options={typeOptions}
                onchange={typeHandler}
            ></lightning-combobox>
            <template if:true={filteredAccounts.data}>
                <template for:each={filteredAccounts.data} for:item="account">
                    <div class="slds-box slds-box_xx-small" key={account.Id}>
                        <p><strong>Name:</strong> {account.Name}</p>
                        <p><strong>Type:</strong> {account.Type}</p>
                    </div>
                </template>
            </template>
        </div>
    </lightning-card>
</template>


JS code 

import { LightningElement, wire } from 'lwc';
import filterAccountTypeType from '@salesforce/apex/AccountController.filterAccountTypeType'
export default class WireApexWithParams extends LightningElement {
    selectedType=''
    @wire(filterAccountTypeType, {type:'$selectedType'})
    filteredAccounts

    get typeOptions(){
        return [
            {label:"Customer - Channel", value:"Customer - Channel"},
            {label:"Customer - Direct", value:"Customer - Direct"}
        ]
    }
    typeHandler(event){
        this.selectedType = event.target.value
    }
}


Apex code 

 

Call Apex method imperatively 

	To call a method that isn’t annotated with cacheable= true, which includes any method that inserts, update or delete data
	To control when the invocations occurs. Basically wire will execute on page loads. So we have requirement to call apex on click or some action we will use this approach.
	To work with objects that aren’t supported by User Interface API like task and Even.
	To call a method from ES6 module that deosn’t extend Lightning element.

Call Apex imperatively when you need to control the invocation of read operations, and when you modify records. To call Apex imperatively, you invoke Apex one time from a component’s JavaScript file instead of delegating control to the Lightning Web Components engine. In return, you get a JavaScript promise (as you do when you call an LDS function imperatively).
You can call both cacheable and non-cacheable Apex methods imperatively. To refresh the cache for a cacheable method, call the method again.


 


HTML code 

<template>
    <lightning-card title="Apex imperative with params demo">
        <div class="slds-p-around_medium">
            <lightning-input
            type="search"
            onchange={searchHandler}
            label="Search Account"
            value={searchKey}
            ></lightning-input>
        </div>

        <template if:true={accounts}>
            <template for:each={accounts} for:item="account">
                <div class="slds-box slds-box_xx-small" key={account.Id}>
                    <p>Name - {account.Name}</p>
                    <p>Type - {account.Type}</p>
                    <p>Industry - {account.Industry}</p>
                </div>
            </template>
        </template>

    </lightning-card>
</template>

JS code 
import { LightningElement } from 'lwc';
import findAccounts from '@salesforce/apex/AccountController.findAccounts'
export default class ApexImperativeWithParamsDemo extends LightningElement {
    searchKey=''
    accounts
    timer
    searchHandler(event){
        window.clearTimeout(this.timer)
        this.searchKey = event.target.value
        this.timer = setTimeout(()=>{
            this.callApex()
        }, 1000)
    }

    callApex(){
        findAccounts({searchKey:this.searchKey})
        .then(result=>{
            this.accounts = result
        }).catch(error=>{
            console.error(error)
        })
    }
}
Apex code 

public with sharing class AccountController {
    @AuraEnabled(cacheable=true)
    public static List<Account> getAccountList(){
        return [SELECT Id, Name, Type, Industry from Account LIMIT 5];
    }

    @AuraEnabled(cacheable=true)
    public static List<Account> filterAccountTypeType(String type){
        return [SELECT Id, Name, Type from Account where Type=:type LIMIT 5];
    }

    @AuraEnabled(cacheable=true)
    public static List<Account> findAccounts(String searchKey){
        String key = '%' + searchKey + '%';
        return [SELECT Id, Name, Type, Industry FROM Account WHERE Name LIKE :key LIMIT 5];
    }

}

Apex imperative method with parameters

HTML code 
<template>
    <lightning-card title="Apex imperative with params demo">
        <div class="slds-p-around_medium">
            <lightning-input
            type="search"
            onchange={searchHandler}
            label="Search Account"
            value={searchKey}
            ></lightning-input>
        </div>

        <template if:true={accounts}>
            <template for:each={accounts} for:item="account">
                <div class="slds-box slds-box_xx-small" key={account.Id}>
                    <p>Name - {account.Name}</p>
                    <p>Type - {account.Type}</p>
                    <p>Industry - {account.Industry}</p>
                </div>
            </template>
        </template>

    </lightning-card>
</template>

JS code 

import { LightningElement } from 'lwc';
import findAccounts from '@salesforce/apex/AccountController.findAccounts'
export default class ApexImperativeWithParamsDemo extends LightningElement {
    searchKey=''
    accounts
    timer
    searchHandler(event){
        window.clearTimeout(this.timer)
        this.searchKey = event.target.value
//here  when we entering data in input suppose ‘test’ tn this case it call callApex method 4 times to avoid continues calling we will set some delay after that we will call.
        this.timer = setTimeout(()=>{
            this.callApex()
        }, 1000)
    }

    callApex(){
        findAccounts({searchKey:this.searchKey})
        .then(result=>{
            this.accounts = result
        }).catch(error=>{
            console.error(error)
        })
    }
}

Apex code 


public with sharing class AccountController {
    @AuraEnabled(cacheable=true)
    public static List<Account> getAccountList(){
        return [SELECT Id, Name, Type, Industry from Account LIMIT 5];
    }

    @AuraEnabled(cacheable=true)
    public static List<Account> filterAccountTypeType(String type){
        return [SELECT Id, Name, Type from Account where Type=:type LIMIT 5];
    }

    @AuraEnabled(cacheable=true)
    public static List<Account> findAccounts(String searchKey){
        String key = '%' + searchKey + '%';
        return [SELECT Id, Name, Type, Industry FROM Account WHERE Name LIKE :key LIMIT 5];
    }

}



16)	Books listing app with Rest API callout


HTML Code: 

<template>
    <lightning-card>
        <div class="slds-p-around_medium">
            <div class="slds-p-around_medium">
                <lightning-input type="search"
                onchange={fetchBooksHandler}
                label="Search Books"
                value={query}></lightning-input>
            </div>
            <lightning-layout multiple-rows>
                <template if:true={books}>
                    <template for:each={books.items} for:item="book">
                        <lightning-layout-item size="3" padding="around-small" key={book.id}>
                           <div class="slds-box slds-p-around_medium slds-text-align_center">
                               <img src={book.volumeInfo.imageLinks.smallThumbnail} height="200px"/>
                               <div class="slds-text-heading_small slds-p-vertical_medium"><strong>{book.volumeInfo.title}</strong></div>
                               <div><strong>Published Date -</strong>{book.volumeInfo.publishedDate}</div>
                               <div><strong>Average Rating - {book.volumeInfo.averageRating}</strong></div>
                           </div>
                        </lightning-layout-item>
                    </template>
                </template>
            </lightning-layout>
        </div>
    </lightning-card>
</template>


JS code:

import { LightningElement } from 'lwc';
const BOOK_URL = 'https://www.googleapis.com/books/v1/volumes?q='
export default class BookApp extends LightningElement {
    query='Man'
    books
    timer
    connectedCallback(){
        this.fetchBookData()
    }

    fetchBookData(){
        fetch(BOOK_URL+this.query)
        .then(response=>response.json())
        .then(data=>{
            console.log(data)
            this.books = data
        })
        .catch(error=>console.error(error))
    }
    fetchBooksHandler(event){
        this.query = event.target.value
        window.clearTimeout(this.timer)
        this.timer= setTimeout(()=>{
            this.fetchBookData()
        }, 1000)
    }
}

17)	Component configuration in LWC


Not use Arrow functions:
Meta configuration in LWC


 


 

 



HTML code


<template>
    <lightning-card title={heading}>
        <div class="slds-p-around_medium">
            <p>{recordId}</p>
            <p>My age is {age}</p>
            <p>My IQ is {levels}</p>
        </div>
        
    </lightning-card>
</template>

JS code:

import { LightningElement, api } from 'lwc';

export default class LwcConfigDemo extends LightningElement {
    @api heading
    @api recordId
    @api age
    @api levels

}

Meta.XML file:

<?xml version="1.0" encoding="UTF-8"?>
<LightningComponentBundle xmlns="http://soap.sforce.com/2006/04/metadata">
    <apiVersion>50.0</apiVersion>
    <description>This component explains Meta configuration</description>
    <isExposed>true</isExposed>
    <masterLabel>Meta Config Demo</masterLabel>
    <targets>
        <target>lightning__AppPage</target>
        <target>lightning__RecordPage</target>
        <target>lightning__HomePage</target>
    </targets>
    <targetConfigs>
        <targetConfig targets="lightning__RecordPage">
            <property name="recordId" type="String"/>
            <property name="heading" type="String" default="Meta Config in LWC"/>
            <objects>
                <object>Account</object>
            </objects>
        </targetConfig>
        <targetConfig targets="lightning__AppPage">
            <property name="heading" type="String" default="Meta Config in LWC"/>
            <property name="age" type="Integer" min="5" max="10" default="7"/>
            <property name="levels" label="Level" type="String" datasource="High, Medium, Low" default="High"/>
        </targetConfig>
    </targetConfigs>
</LightningComponentBundle>

LWC in utility bar

HTML code
<template>
    <lightning-card title="LWC in Utility Bar">
        <div class="slds-p-around_medium">
            <lightning-record-form object-api-name="Account" fields={fieldList}
            columns="1" mode="view"></lightning-record-form>
        </div>
    </lightning-card>
</template>



JS code

import { LightningElement } from 'lwc';

export default class LwcUtilityBar extends LightningElement {
    fieldList = ['Name', 'Phone']
}

Meta.XML file:

<?xml version="1.0" encoding="UTF-8"?>
<LightningComponentBundle xmlns="http://soap.sforce.com/2006/04/metadata">
    <apiVersion>50.0</apiVersion>
    <isExposed>true</isExposed>
    <targets>
        <target>lightning__UtilityBar</target>
    </targets>
</LightningComponentBundle>



LWC in lightning tab

HTML code:

<template>
    <lightning-card title="LWC in lightning Tab">
        <div class="slds-p-around_medium">
            <p>Hello!! Welcome to lightning Tab</p>
        </div>
    </lightning-card>
</template>


JS code

import { LightningElement } from 'lwc';

export default class LwcIntab extends LightningElement {}

Meta.XML file:

<?xml version="1.0" encoding="UTF-8"?>
<LightningComponentBundle xmlns="http://soap.sforce.com/2006/04/metadata">
    <apiVersion>50.0</apiVersion>
    <isExposed>true</isExposed>
    <targets>
        <target>lightning__Tab</target>
    </targets>
</LightningComponentBundle>


18)	Real Time features

PDF generation in LWC 


 


HTML code: In HTML apply inline CSS styles because when we are passing data to VF page or apex class external CSS will not share.  Also try to avoid standard lightning CSS styles because it will use shallow DOM so it will not the styles to apex class.


<template>
    <div class="container" style="background: white;
    padding: 16px;">
        <div style="margin-bottom: 50px;">
            <img src={imageUrl} style="height:40px; width:150px"/>
            <div style="display: inline-block;float: right;">
                <div>Invoice #: {invoiceData.invoiceNo}</div>
                <div>Created #: {invoiceData.invoiceCreated}</div>
                <div>Due #: {invoiceData.invoiceDue}</div>
            </div>
        </div>
        <div>
            <div style="display: inline-block;">
                <div> {invoiceData.companyName}</div>
                <div> {invoiceData.address1}</div>
                <div> {invoiceData.address2}</div>
            </div>
            <div style="display: inline-block;float: right; text-align: right;">
                <div> {clientData.client}</div>
                <div> {clientData.username}</div>
                <div> {clientData.email}</div>
            </div>
        </div>
        <div style="background: #eee;
        margin: 16px 0px;
        padding: 8px;">
            <div  style="display: inline-block"><strong>Services</strong></div>
            <div style="display: inline-block;float: right;"><strong>Amount</strong></div>
        </div>
        <template iterator:service={services}>
            <div key={service.value.name} style="padding: 8px;">
                <div style="display: inline-block">{service.value.name}</div>
                <div style="display: inline-block;float: right;">${service.value.amount}</div>
            </div>
            <div if:true={service.last} key={service.value.name}  style="padding: 8px;">
                <div style="display: inline-block;float: right;"><strong>Total Amount:${totalAmount} </strong></div>
            </div>
        </template>
    </div>
    <lightning-button variant="brand" label="generate pdf" onclick={pdfHandler}></lightning-button>
</template>

JS code 


import { LightningElement, api } from 'lwc';
import generatePDF from '@salesforce/apex/pdfController.generatePDF'
export default class PdfGenerationDemo extends LightningElement {
    @api recordId
    imageUrl = 'https://www.sparksuite.com/images/logo.png'
    invoiceData={
        invoiceNo:'123',
        invoiceCreated:'January 1, 2019',
        invoiceDue:'January 10, 2020',
        companyName:'Sparksuite, Inc.',
        address1:'12345 Sunny Road',
        address2:' Sunnyville, CA 12345'
    }
    clientData={
        client:'Acme Corp',
        username:'John Doe',
        email:'john@example.com'
    }
    services=[
        {name:'Consultant fee', amount:1000.00},
        {name:'Website design', amount:300.00},
        {name:'Hosting (3 months)', amount:75.00}
    ]

    get totalAmount(){
        return this.services.reduce((total, service)=>{
            return total = total+service.amount
        }, 0)
    }

    pdfHandler(){
        let content = this.template.querySelector('.container')
        console.log(content.outerHTML)
        generatePDF({ recordId:this.recordId, htmlData:content.outerHTML}).then(result=>{
            console.log("attachment id", result)
	// get below link when you open the attchement in notes section once you open that it will giv some link we nned to fetch from there. Refer video 
            window.open(`https://agility-fun-2547-dev-ed--c.documentforce.com/servlet/servlet.FileDownload?file=${result.Id}`)
        }).catch(error=>{
            console.error(error)
        })
    }
}


Apex class:


public with sharing class pdfController {
    @AuraEnabled
    public static Attachment generatePDF(Id recordId, String htmlData){
        Pagereference page = Page.renderAsPDF;
        page.getParameters().put('pdfText', htmlData);

        Contact con = new Contact(Id=recordId);
        Attachment objAttachment = new Attachment();
        objAttachment.Name='invoice.pdf';
        objAttachment.ParentId = con.Id;
        objAttachment.Body = page.getContentaspdf();
        objAttachment.IsPrivate = false;
        insert objAttachment;
        return objAttachment;
    }
}



VF page


<apex:page controller="pdfPageController" renderAs="pdf" applyHtmlTag="false" showHeader="false" cache="true" readOnly="true">
    <html>
        <head>
            <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
        </head>
        <apex:outputText value="{!pdfText}" escape="false"/>
    </html>

</apex:page>



Apex class:

public with sharing class pdfPageController {
    public String pdfText{get;set;}
    public pdfPageController() {
        pdfText = String.escapeSingleQuotes(
            ApexPages.currentPage().getParameters().get('pdfText')
        );
    }
}

Charts in LWC

HTML: 

<template>
    <div class="chart slds-var-m-around_medium" lwc:dom="manual">
        
    </div>
</template>

JS code


import { LightningElement, api } from 'lwc';
import chartJs from '@salesforce/resourceUrl/chartJs'
import {loadScript} from 'lightning/platformResourceLoader'
export default class Charts extends LightningElement {
    isChartJsInitialized
    chart
    @api type
    @api chartData
    @api chartHeading
    @api chartLabels


    renderedCallback(){
        if(this.isChartJsInitialized){
            return;
        }
        loadScript(this, chartJs+'/chartJs/Chart.js').then(()=>{
            console.log("chartJs loaded succesfully")
            this.isChartJsInitialized = true
            this.loadCharts()
        }).catch(error=>{
            console.error(error)
        })
    }

    loadCharts(){
        window.Chart.platform.disableCSSInjection = true

        const canvas = document.createElement('canvas')
        this.template.querySelector('div.chart').appendChild(canvas)
        const ctx = canvas.getContext('2d')
        this.chart = new window.Chart(ctx, this.config())
    }
    config(){
        return {
            type: this.type,
            data: {
                labels: this.chartLabels ? this.chartLabels:[],
                datasets: [{
                    label: this.chartHeading,
                    data: this.chartData ? this.chartData:[],
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.8)',
                        'rgba(54, 162, 235, 0.8)',
                        'rgba(255, 206, 86, 0.8)',
                        'rgba(75, 192, 192, 0.8)',
                        'rgba(153, 102, 255, 0.8)',
                        'rgba(255, 159, 64, 0.8)',
                        'rgba(30, 204, 148, 0.8)',
                        'rgba(130, 204, 148, 0.8)'
                        
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                legend: {
                    position: 'right'
                },
                animation: {
                    animateScale: true,
                    animateRotate: true
                }
            }
        }
    }
}



HTML code

<template>
    <lightning-layout multiple-rows>
        <lightning-layout-item size="6" padding="around-small">
            <lightning-card title="Total Opportunities">
                <template if:true={pieChartLabels.length}>
                    <c-charts type="doughnut" 
                    chart-heading="Opportunities"
                    chart-data={pieChartData} 
                    chart-labels={pieChartLabels}
                    ></c-charts>
                </template>
                
            </lightning-card>
        </lightning-layout-item>
        <lightning-layout-item size="6" padding="around-small">
            <lightning-card title="Total Opportunities 2">
                <template if:true={pieChartLabels.length}>
                    <c-charts type="bar" 
                    chart-heading="Zero to hero"
                    chart-data={pieChartData} 
                    chart-labels={pieChartLabels}
                    ></c-charts>
                </template>
            </lightning-card>
        </lightning-layout-item>
    </lightning-layout>
</template>


JS code 

import { LightningElement, wire } from 'lwc';
import getOpportunities from '@salesforce/apex/OpportunityController.getOpportunities'
export default class ChartsDemo extends LightningElement {
    pieChartLabels=[]
    pieChartData=[]
    @wire(getOpportunities)
    opportunityHandler({data, error}){
        if(data){
            console.log(data)
            const result = data.reduce((json, val)=>({...json, [val.StageName]:(json[val.StageName]|0)+1}), {})
            if(Object.keys(result).length){
                this.pieChartLabels = Object.keys(result)
                this.pieChartData = Object.values(result)
            }
        
        }
        if(error){
            console.error(error)
        }
    }
}

Apex Class

public with sharing class OpportunityController {
    @AuraEnabled(cacheable=true)
    public static List<Opportunity> getOpportunities(){
        return [SELECT StageName FROM Opportunity];
    }
}



Maps in LWC 

HTML code


<template>
    <div class="slds-box">
        <template if:true={mapMarkers.length}>
            <lightning-map 
                map-markers={mapMarkers}
                markers-title={markersTitle}
                onmarkerselect={callMarkerHandler}
                selected-marker-value={selectedMarker}>
            </lightning-map>
        </template>
        <template if:false={mapMarkers.length}>
            <div>No Account Found</div>
        </template>
        
    </div>
</template>


JS code 

import { LightningElement, wire } from 'lwc';
import getAccounts from '@salesforce/apex/MapControllerLwc.getAccounts'
export default class MapsInLwcDemo extends LightningElement {
    mapMarkers=[]
    markersTitle="Accounts Location"
    @wire(getAccounts)
    wireHandler({data, error}){
        if(data){
            console.log(data)
            this.formatResponse(data)
        }
        if(error){
            console.error(error)
        }
    }

    formatResponse(data){
        this.mapMarkers = data.map(item=>{
            return {
                location:{
                    Street:item.BillingCity || '',
                    City:item.BillingCity ||'',
                    PostalCode: item.BillingPostalCode || '',
                    State: item.BillingState || '',
                    Country: item.BillingCountry || ''
                },
                icon:'utility:salesforce1',
                title:item.Name,
                value:item.Name,
                description:item.description
            }
        })
        this.selectedMarker = this.mapMarkers.length && this.mapMarkers[0].value
    }
    callMarkerHandler(event){
        this.selectedMarker = event.detail.selectedMarkerValue
    }

}

Apex class


public with sharing class MapControllerLwc {
   @AuraEnabled(cacheable=true)
   public static List<Account> getAccounts(){
       return [SELECT Id, Name, description, BillingStreet, 
       BillingCountry, BillingCity, BillingState,
       BillingPostalCode FROM Account ORDER BY Name LIMIT 10];
   }
}




Filtering in LWC 


HTML code

<template>
    <lightning-card title="Client Side Filtering Demo">
        <div class="slds-p-around_medium">
            <lightning-layout>
                <lightning-layout-item size="2" padding="around-small">
                   <lightning-combobox name="filterBy" value={filterBy} label="Filter By"
                   options={FilterByOptions} onchange={filterbyHandler}></lightning-combobox>
                </lightning-layout-item>
                <lightning-layout-item size="4" padding="around-small">
                    <lightning-input type="text" label="Filter" onkeyup={filterHandler}></lightning-input>
                </lightning-layout-item>
            </lightning-layout>
            <table>
                <thead>
                    <tr>
                        <template for:each={headings} for:item="heading">
                            <th key={heading}>{heading}</th>
                        </template>
                    </tr>
                </thead>
                <tbody>
                    <template for:each={filteredData} for:item="data">
                        <tr key={data.Id}>
                            <td>{data.Id}</td>
                            <td>{data.Name}</td>
                            <td>{data.Title}</td>
                            <td>{data.Email}</td>
                        </tr>
                    </template>
                    
                </tbody>
            </table>
        </div>
    </lightning-card>
</template>

JS code 

import { LightningElement, wire } from 'lwc';
import getContactList from '@salesforce/apex/ContactController.getContactList'
export default class FilteringAndSortingDemo extends LightningElement {
    headings=["Id", "Name", "Title", "Email"]
    fullTableData=[]
    filteredData=[]
    timer
    filterBy="Name"
    @wire(getContactList)
    contactHandler({data, error}){
        if(data){
            console.log(data)
            this.fullTableData = data
            this.filteredData= data
        }
        if(error){
            console.log(error)
        }
    }

    get FilterByOptions(){
        return [
            {label:"All", value:'All'},
            {label:"Id", value:'Id'},
            {label:'Name', value:'Name'},
            {label:'Title', value:'Title'},
            {label:'Email', value:'Email'}
        ]
    }

    filterbyHandler(event){
        this.filterBy = event.target.value
    }

    filterHandler(event){
        const {value} = event.target
        window.clearTimeout(this.timer)
        if(value){
            this.timer = window.setTimeout(()=>{
                console.log(value)
                this.filteredData = this.fullTableData.filter(eachObj=>{
                    if(this.filterBy === 'All'){
                        /**Below logic will filter each and every property of object */
                        return Object.keys(eachObj).some(key=>{
                            return eachObj[key].toLowerCase().includes(value)
                        })
                    } else {
                         /**Below logic will filter only selected fields */
                        const val = eachObj[this.filterBy] ? eachObj[this.filterBy]:''
                        return val.toLowerCase().includes(value)
                    }
                })
            }, 500)
            
        } else {
            this.filteredData = [...this.fullTableData]
        }
        
    }
}

CSS 

table{
    border-collapse:collapse;
    width: 100%;
}
td, th{
    border:1px solid #ddd;
    text-align: left;
    padding: 8px;
}
tr:nth-child(even){
    background-color: #ddd;
}

Apex class

public with sharing class ContactController {
    @AuraEnabled(cacheable=true)
    public static List<Contact> getContactList(){
        return [SELECT Id, Name, Title, Email from Contact];
    }
}



Sorting in LWC

HTML code


<template>
    <lightning-card title="Client Side Filtering Demo">
        <div class="slds-p-around_medium">
            <lightning-layout>
                <lightning-layout-item size="2" padding="around-small">
                   <lightning-combobox name="filterBy" value={filterBy} label="Filter By"
                   options={FilterByOptions} onchange={filterbyHandler}></lightning-combobox>
                </lightning-layout-item>
                <lightning-layout-item size="4" padding="around-small">
                    <lightning-input type="text" label="Filter" onkeyup={filterHandler}></lightning-input>
                </lightning-layout-item>
                <!---Sorting dropdown-->
                <lightning-layout-item size="2" alignment-bump="left" padding="around-small">
                    <lightning-combobox name="sortedBy" value={sortedBy} label="Sort By"
                   options={sortByOptions} onchange={sortHandler}></lightning-combobox>
                </lightning-layout-item>
            </lightning-layout>
            <table>
                <thead>
                    <tr>
                        <template for:each={headings} for:item="heading">
                            <th key={heading}>{heading}</th>
                        </template>
                    </tr>
                </thead>
                <tbody>
                    <template for:each={filteredData} for:item="data">
                        <tr key={data.Id}>
                            <td>{data.Id}</td>
                            <td>{data.Name}</td>
                            <td>{data.Title}</td>
                            <td>{data.Email}</td>
                        </tr>
                    </template>
                    
                </tbody>
            </table>
        </div>
    </lightning-card>
</template>


JS code 

import { LightningElement, wire } from 'lwc';
import getContactList from '@salesforce/apex/ContactController.getContactList'
export default class FilteringAndSortingDemo extends LightningElement {
    headings=["Id", "Name", "Title", "Email"]
    fullTableData=[]
    filteredData=[]
    timer
    filterBy="Name"

    sortedBy = 'Name'
    sortDirection='asc'
    @wire(getContactList)
    contactHandler({data, error}){
        if(data){
            console.log(data)
            this.fullTableData = data
            this.filteredData= [...this.sortBy(data)]
        }
        if(error){
            console.log(error)
        }
    }

    get FilterByOptions(){
        return [
            {label:"All", value:'All'},
            {label:"Id", value:'Id'},
            {label:'Name', value:'Name'},
            {label:'Title', value:'Title'},
            {label:'Email', value:'Email'}
        ]
    }
    get sortByOptions(){
        return [
            {label:"Id", value:'Id'},
            {label:'Name', value:'Name'},
            {label:'Title', value:'Title'},
            {label:'Email', value:'Email'}
        ]
    }

    filterbyHandler(event){
        this.filterBy = event.target.value
    }

    filterHandler(event){
        const {value} = event.target
        window.clearTimeout(this.timer)
        if(value){
            this.timer = window.setTimeout(()=>{
                console.log(value)
                this.filteredData = this.fullTableData.filter(eachObj=>{
                    if(this.filterBy === 'All'){
                        /**Below logic will filter each and every property of object */
                        return Object.keys(eachObj).some(key=>{
                            return eachObj[key].toLowerCase().includes(value)
                        })
                    } else {
                         /**Below logic will filter only selected fields */
                        const val = eachObj[this.filterBy] ? eachObj[this.filterBy]:''
                        return val.toLowerCase().includes(value)
                    }
                })
            }, 500)
            
        } else {
            this.filteredData = [...this.fullTableData]
        }
        
    }

    /****sorting logic */
    sortHandler(event){
        this.sortedBy = event.target.value
        this.filteredData = [...this.sortBy(this.filteredData)]
    }

    sortBy(data){
        const cloneData = [...data]
        cloneData.sort((a,b)=>{
            if(a[this.sortedBy] === b[this.sortedBy]){
                return 0
            }
            return this.sortDirection === 'desc' ? 
            a[this.sortedBy] > b[this.sortedBy] ? -1:1 :
            a[this.sortedBy] < b[this.sortedBy] ? -1:1
        })
        return cloneData
    }

}


CSS

table{
    border-collapse:collapse;
    width: 100%;
}
td, th{
    border:1px solid #ddd;
    text-align: left;
    padding: 8px;
}
tr:nth-child(even){
    background-color: #ddd;
}


Reusable model component in LWC 

HTML code: find below HTMl code LDS by searching modal 

<template>
    <section role="dialog" tabindex="-1" class="slds-modal slds-fade-in-open slds-modal_small" aria-labelledby="modal-heading-01" aria-modal="true" aria-describedby="modal-content-id-1">
        <div class="slds-modal__container">
          <header class="slds-modal__header remove_header">
            <button class="slds-button slds-button_icon slds-modal__close slds-button_icon-inverse" title="Close">
                <lightning-icon onclick={closeModal} icon-name="utility:close" variant="inverse" alternative-text="close" title="Close">
              </lightning-icon>
            </button>
            <div id="modal-heading-01" class="slds-modal__title slds-hyphenate">
                <slot name="title" onslotchange={handleSlotHeaderChange}></slot>
            </div>
          </header>
          <div class="slds-modal__content slds-p-around_medium" id="modal-content-id-1">
                <slot></slot>
          </div>
          <footer class="slds-modal__footer slds-hide">
            <slot name="footer" onslotchange={handleSlotFooterChange}></slot>
          </footer>
        </div>
      </section>
      <div class="slds-backdrop slds-backdrop_open"></div> 
</template>


JS code 


import { LightningElement } from 'lwc';

export default class Modal extends LightningElement {

    closeModal(){
       this.dispatchEvent(new CustomEvent('close'))
    }

    handleSlotFooterChange(){
        const footerElement = this.template.querySelector('.slds-modal__footer')
        if(footerElement){
            footerElement.classList.remove('slds-hide')
        }
    }

    handleSlotHeaderChange(){
        const headerElement = this.template.querySelector('.slds-modal__header')
        if(headerElement){
            headerElement.classList.remove('remove_header')
        }
    }
}


CSS 

.remove_header{
    padding:0px !important;
    border:0px !important;
}


HTML code

<template>
    <lightning-card title="Modal Component Demo">
        <div class="slds-p-around_medium">
            <lightning-button variant="brand" label="open" onclick={openHandler}></lightning-button>
            <lightning-button variant="brand" label="open Second" onclick={openSecondHandler}></lightning-button>
        </div>
    </lightning-card>
    <template if:true={isOpen}>
        <c-modal onclose={closeHandler}>
            <h1 slot="title">Modal header</h1>
            <p>Sit nulla est ex deserunt exercitation anim occaecat. Nostrud ullamco deserunt aute id consequat veniam incididunt duis in sint irure nisi. Mollit officia cillum Lorem ullamco minim nostrud elit officia tempor esse quis.
                Cillum sunt ad dolore quis aute consequat ipsum magna exercitation reprehenderit magna. </p>
            <div slot="footer">
                <button class="slds-button slds-button_neutral" onclick={closeHandler}>Cancel</button>
                <button class="slds-button slds-button_brand">Save</button>
            </div>
        </c-modal>
    </template>

    <template if:true={isOpenSecond}>
        <c-modal onclose={secondCloseHandler}>
            <h1 slot="title">Second Modal header</h1>
            <p>Hello Everyone i am second modal </p>
            <div slot="footer">
                <button class="slds-button slds-button_neutral" onclick={secondCloseHandler}>Cancel</button>
                <button class="slds-button slds-button_brand">Save</button>
            </div>
        </c-modal>
    </template>
   
</template>


JS code

import { LightningElement } from 'lwc';

export default class ModalWrapper extends LightningElement {
    isOpen = false
    isOpenSecond = false
    openHandler(){
        console.log("Clicked!!")
        this.isOpen = true
    }
    openSecondHandler(){
        this.isOpenSecond = true
    }
    closeHandler(){
        this.isOpen = false
    }
    secondCloseHandler(){
        this.isOpenSecond = false
    }
}


Date validation

HTML code

<template>
   <lightning-card title="Date Validation">
       <div class="slds-p-around_medium">
           <lightning-input type="date" name="startDate" label="Start Date" 
           onchange={dateHandler}></lightning-input>
           <lightning-input type="date" name="endDate" label="End Date" 
           onchange={dateHandler}></lightning-input>
           
           <template if:true={error}>
            <p class="slds-text-color_error">{error}</p>
           </template>
           
           <lightning-button variant="brand" label="submit" onclick={submitHandler}
           class="slds-m-top_medium"></lightning-button>
       </div>
   </lightning-card> 
</template>


JS code 

import { LightningElement } from 'lwc';

export default class DateValidation extends LightningElement {
    startDate
    endDate
    error
    dateHandler(event){
        const {name, value} = event.target
        this[name] = value 
    }

    submitHandler(){
        if(this.validateDate(this.startDate, this.endDate)){
            console.log("Data is Valid")
        } else{
            this.error = "End Date cannot be greater than Start Date"
        }
    }

    validateDate(startDate, endDate){
        return new Date(startDate).getTime() < new Date(endDate).getTime()
    }
}



CSV generation in LWC

HTML code

<template>
    <lightning-card title="CSV Demo">
        <div class="slds-p-around_medium">
            <template if:true={accountData}>
                <template for:each={accountData} for:item="account">
                    <p key={account.Id}>{account.Name}</p>
                </template>
            </template>
            <lightning-button label="Generate CSV" onclick={csvGenerator} variant="brand"></lightning-button>
        </div>
    </lightning-card>
</template>


JS code 

import { LightningElement, wire } from 'lwc';
import getAccounts from '@salesforce/apex/CsvController.getAccounts'
import {exportCSVFile} from 'c/utils'
export default class CsvDemo extends LightningElement {
    accountData
    accountHeaders={
        Id:"Record Id",
        Name:"Name",
        AnnualRevenue:"Annual Revenue",
        Industry:"Industry",
        Phone:"Phone"
    }
    @wire(getAccounts)
    accountHandler({data, error}){
        if(data){
            console.log(data)
            this.accountData = data
        }
        if(error){
            console.error(error)
        }
    }

    csvGenerator(){
        //headers, totalData, fileTitle
        exportCSVFile(this.accountHeaders, this.accountData, "account_records")
    }
}

Apex class

public with sharing class CsvController {
    @AuraEnabled(cacheable=true)
    public static List<Account> getAccounts(){
        return [SELECT Id, Name, Phone, AnnualRevenue, Industry from Account];
    }
}


Other JS

export function exportCSVFile(headers, totalData, fileTitle){
    if(!totalData || !totalData.length){
        return null
    }
    const jsonObject = JSON.stringify(totalData)
    const result = convertToCSV(jsonObject, headers)
    if(!result){
        return null
    }
    const blob = new Blob([result])
    const exportedFileName = fileTitle? fileTitle+'.csv':'export.csv'
    if(navigator.msSaveBlob){
        navigator.msSaveBlob(blob, exportedFileName)
    } else if (navigator.userAgent.match(/iPhone|iPad|iPod/i)){
        const link = window.document.createElement('a')
        link.href='data:text/csv;charset=utf-8,' + encodeURI(result);
        link.target = "_blank"
        link.download=exportedFileName
        link.click()
    } else {
        const link = window.document.createElement('a')
        if(link.download !== undefined){
            const url = URL.createObjectURL(blob)
            link.setAttribute("href", url)
            link.setAttribute("download", exportedFileName)
            link.style.visibility='hidden'
            document.body.appendChild(link)
            link.click()
            document.body.removeChild(link)
        }
    }
}

function convertToCSV(objArray, headers){
    const columnDelimiter = ','
    const lineDelimiter = '\r\n'
    const actualHeaderKey = Object.keys(headers)
    const headerToShow = Object.values(headers)
    
    let str = ''
    str+=headerToShow.join(columnDelimiter)
    str+=lineDelimiter
    const data = typeof objArray !=='object' ? JSON.parse(objArray):objArray
    data.forEach(obj=>{
        let line =''
        actualHeaderKey.forEach(key=>{
            if(line !=''){
                line+=columnDelimiter
            }
            
            let strItem = obj[key] ? obj[key]+'': ''
            line+=strItem? strItem.replace(/,/g, ''):strItem
        })
        str+=line+lineDelimiter
    })
    return str
}



Custom Carousel using LWC

HTML code

<template>
    <div class="slds-is-relative container" style={maxWidth}>
        <template for:each={slidesData} for:item="slide">
            <div class={slide.cardClasses} key={slide.slideIndex}>
                <div class="slideNumbers">{slide.slideIndex}/{slidesData.length} </div>
                <img src={slide.image}/>
                <div class="text-section slds-p-around_medium">
                    <h3 class="slds-text-heading_large">{slide.heading}</h3>
                    <div class="slds-text-heading_small">{slide.description}</div>
                </div>
            </div>
        </template>
        <a class="prev" onclick={backSlide}>&#10094;</a>
        <a class="next" onclick={forwardSlide}>&#10095;</a>
    </div>
    <div class="slds-text-align_center slds-p-around_medium">
        <template for:each={slidesData} for:item="slide">
            <span class={slide.dotClases} data-id={slide.slideIndex} key={slide.slideIndex} onclick={currentSlide}></span>
        </template>
    </div>
</template>



JS code 



/***********
 * enable-auto-scroll for autoScroll to enable
 * slide-timer for controlling the slider speed default is 3000
 * slides-data is the data and data should be in this format {image:'',heading:'',description:''}
 * show-full is for 100% width other wise use customWidth 
 * custom-width is use for controlling the width of the slider manually
 * 
 */
import { LightningElement, api } from 'lwc';

const CARD_VISIBLE_CLASSES = 'fade slds-show'
const CARD_HIDDEN_CLASSES = 'fade slds-hide'

const DOT_VISIBLE_CLASSES = 'dot active'
const DOT_HIDDEN_CLASSES = 'dot'

const DEFAULT_SLIDER_TIMER = 3000 // 3 second
const DEFAULT_SLIDER_WIDTH = 700
export default class CustomCarousel extends LightningElement {
    slides=[]
    slideIndex = 1
    timer

    @api slideTimer = DEFAULT_SLIDER_TIMER
    @api enableAutoScroll = false
    @api customWidth = DEFAULT_SLIDER_WIDTH
    @api showFull = false

    get maxWidth(){
        return this.showFull ? `width:100%`: `width:${Number(this.customWidth)}px`
    }

    @api 
    get slidesData(){
        return this.slides
    }

    set slidesData(data){
        this.slides = data.map((item, index)=>{
            return index === 0 ? {
                ...item,
                slideIndex: index+1,
                cardClasses:CARD_VISIBLE_CLASSES,
                dotClases:DOT_VISIBLE_CLASSES
            }:{
                ...item,
                slideIndex: index+1,
                cardClasses:CARD_HIDDEN_CLASSES,
                dotClases:DOT_HIDDEN_CLASSES
            }
        })
    }

    connectedCallback(){
        if(this.enableAutoScroll){
            this.timer = window.setInterval(()=>{
                this.slideSelectionHandler(this.slideIndex+1)
        }, Number(this.slideTimer))
        }
       
    }

    disconnectedCallback(){
        if(this.enableAutoScroll){
            window.clearInterval(this.timer)
        }
    }
    currentSlide(event){
        let slideIndex  = Number(event.target.dataset.id)
        this.slideSelectionHandler(slideIndex) 
    }
    backSlide(){
        let slideIndex  = this.slideIndex - 1
        this.slideSelectionHandler(slideIndex)
    }
    forwardSlide(){
       let slideIndex  = this.slideIndex +1
       this.slideSelectionHandler(slideIndex)
    }

    slideSelectionHandler(id){
        if(id > this.slides.length){
            this.slideIndex = 1
        } else if(id < 1){
            this.slideIndex = this.slides.length
        } else {
            this.slideIndex = id
        }
        this.slides = this.slides.map(item=>{
            return this.slideIndex === item.slideIndex ? {
                ...item,
                cardClasses:CARD_VISIBLE_CLASSES,
                dotClases:DOT_VISIBLE_CLASSES
            }:{
                ...item,
                cardClasses:CARD_HIDDEN_CLASSES,
                dotClases:DOT_HIDDEN_CLASSES
            }
        })
    }

}

CSS


.container{
    margin: auto;
}
.text-section{
    position: absolute;
    color: #f2f2f2;
    font-size: 15px;
    bottom: 0px;
    width: 100%;
    text-align: center;
    background: rgba(0,0,0, 0.7);
}
.prev, .next{
    position: absolute;
    top: 50%;
    width: auto;
    padding: 16px;
    color: #fff;
    font-weight: 700;
    cursor: pointer;
    border-radius: 0 3px 3px 0;
    user-select: none;
}
.next{
    right:0;
    border-radius: 3px 0 0 3px;
}
.prev:hover, .next:hover{
    background: rgba(0,0,0, 0.8);
}

.slideNumbers{
    font-size: 12px;
    position: absolute;
    padding: 8px 12px;
    top: 0;
    color: #f2f2f2;
}

.dot{
    height: 15px;
    width: 15px;
    border-radius: 50%;
    cursor: pointer;
    background-color: #bbb;
    margin:0 2px;
    display: inline-block;
}
.active, .dot:hover{
    background-color: #717171;
}

.fade{
    animation-name:fade;
    animation-duration: 1.5s;
}
@keyframes fade{
    from {opacity: .4}
    to {opacity: 1}
}


HTML Wrapper:

<template>
    <c-custom-carousel slides-data={slides} ></c-custom-carousel>
    <!-- enable-auto-scroll slide-timer="5000" -->
</template>

JS wrapper

import { LightningElement } from 'lwc';
import CAROUSEL_IMAGES from '@salesforce/resourceUrl/carousel'
export default class CustomCarouselWrapper extends LightningElement {

    slides= [
        {
            image:`${CAROUSEL_IMAGES}/carousel/photo1.jpg`,
            heading:'Caption one',
            description:'You can add description of first slide here'
        },
        {
            image:`${CAROUSEL_IMAGES}/carousel/photo2.jpg`,
            heading:'Caption Two',
            description:'You can add description of second slide here'
        },
        {
            image:`${CAROUSEL_IMAGES}/carousel/photo3.jpg`,
            heading:'Caption Three',
            description:'You can add description of third slide here'
        }
    ]
}









19)	Jest





20)	Test












